O:9:"MagpieRSS":20:{s:6:"parser";i:0;s:12:"current_item";a:0:{}s:5:"items";a:10:{i:0;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-115038743842667999";s:7:"pubdate";s:31:"Thu, 15 Jun 2006 15:39:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-06-15T11:03:58.583-05:00";}s:5:"title";s:27:"Oracle Spatial + Where 2.0?";s:11:"description";s:677:"Ok...<br /><br />So I just got back from the Where 2.0 conference.  All in all it was a pretty good show.  I have my issues with some of the talks, but overall it was really good.  The question I have is.  <span style="font-style: italic;">Where was Oracle?</span> <br /><br />Don't you think that Oracle Spatial should have been there?<br /><br />Maybe I missed them, but they were not presenting and they were not in the participant list.<br /><br />Intel, Google, Yahoo, Microsoft, Autodesk, ESRI, MapInfo, Ask, AOL, Cisco, Motorola, MapQuest, eBay, Apple, and many others were there.<br /><br />Some presenters really talked about Oracle Spatial though...<br /><br />Jeremy";s:4:"link";s:63:"http://geosql.blogspot.com/2006/06/oracle-spatial-where-20.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"5";}s:7:"summary";s:677:"Ok...<br /><br />So I just got back from the Where 2.0 conference.  All in all it was a pretty good show.  I have my issues with some of the talks, but overall it was really good.  The question I have is.  <span style="font-style: italic;">Where was Oracle?</span> <br /><br />Don't you think that Oracle Spatial should have been there?<br /><br />Maybe I missed them, but they were not presenting and they were not in the participant list.<br /><br />Intel, Google, Yahoo, Microsoft, Autodesk, ESRI, MapInfo, Ask, AOL, Cisco, Motorola, MapQuest, eBay, Apple, and many others were there.<br /><br />Some presenters really talked about Oracle Spatial though...<br /><br />Jeremy";}i:1;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-114479206731332148";s:7:"pubdate";s:31:"Tue, 11 Apr 2006 21:41:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-04-11T22:08:45.503-05:00";}s:5:"title";s:35:"Consuming REST services with Oracle";s:11:"description";s:6520:"<span style="color: rgb(0, 0, 0);font-family:arial;" >I love </span><a style="font-family: arial; color: rgb(51, 102, 255);" href="http://webservices.xml.com/pub/a/ws/2002/02/06/rest.html">REST</a><span style="color: rgb(0, 0, 0);font-family:arial;" > services (representation state transfer).   They provide a powerful yet simple way of consuming data via the web (Some examples of REST services:  <a href="http://developer.yahoo.com/search/index.html">Yahoo</a>, some <a href="http://ashburnarcweb.esri.com/v2006/develop/rest.jsp">ArcWeb Services</a>, <a href="http://www.mapdex.org/cfcdoc/mapdex.html">Mapdex API</a>, <a href="http://www.flickr.com/services/api/request.rest.html">Flickr</a>, even <a href="http://portal.opengeospatial.org/files/?artifact_id=14416">WMS </a>services).    Here is an example of one I made up.</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:arial;" >I want to be able to query the National Elevation Dataset (via http://seamless.usgs.gov ) to find out what the elevation is at a particular latitude, longitude coordinate.  I want to submit a geographic point and extract the elevation value at the point.  USGS is publishing this as an ArcIMS image service </span><span style="color: rgb(0, 0, 0);font-family:arial;" >(<a href="http://www.mapdex.org/getserviceinfo_style.cfm?server_id=ortho.cr.usgs.gov&service_name=USGS_EDC_Elev_NED&amp;server_ip=152.61.128.152">USGS_EDC_Elev_NED</a>)</span><span style="color: rgb(0, 0, 0);font-family:arial;" >.     I can use the <a href="http://edndoc.esri.com/arcims/9.1/elements/get_raster_info.htm">get_raster_info</a> request to extract the elevation at a particular point.<br /><br /><a href="http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.cfm?latitude=38&longitude=-115&amp;mapserver=seamless.usgs.gov&mapservice=USGS_EDC_Elev_NED&amp;layer_id=NED.CONUS_NED">Here</a> is my test REST service:</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:arial;" ><pre>http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.cfm?<br />latitude=38&longitude=-115<br />&amp;mapserver=seamless.usgs.gov<br />&mapservice=USGS_EDC_Elev_NED<br />&amp;layer_id=NED.CONUS_NED</pre></span><br /><span style="color: rgb(0, 0, 0);font-family:arial;" ><br />You can view the source code <a href="http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.txt">here</a>.<br /><br />It queries the service and reformats the ArcIMS response to the following XML output:</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >&lt;NED_ELEVATION&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" > &lt;ELEVATION_LOCATION latitude="38" longitude="-115"&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >   &lt;ELEVATION_METERS&gt;1627.53918457031&lt;/ELEVATION_METERS&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >   &lt;ELEVATION_FEET&gt;5339.95606458&lt;/ELEVATION_FEET&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" > &lt;/ELEVATION_LOCATION&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >&lt;/NED_ELEVATION&gt;</span><span style="color: rgb(0, 0, 0);font-family:courier new;" ><br /><br /><br /><span style="font-family:arial;">In order to access this document in Oracle we need to take advantage of two features.  One is the utl_http package (see <a href="http://asktom.oracle.com/pls/ask/f?p=4950:8:::::F4950_P8_DISPLAYID:285215954607">AskTom</a> or the Oracle docs for more info) to request an html page via a url.<br /><br /></span></span><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/utl_http.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/utl_http.jpg" alt="" border="0" /></a><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><span style="font-family:arial;">This query will actually return the text/xml response from the server as a 4000 character string to the sqlplus window (use request_pieces for larger files).<br /><br /></span><span style="font-family:arial;">We then have to turn this character representation into an xml document so we can query it.<br /><br /></span></span></span><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;">To do this we can use the <a href="http://www.oracle.com/technology/oramag/oracle/01-nov/o61xml.html">xmltype</a> datatype (an Oracle system defined datatype) that allows us to parse an xml document and query it via xpath.</span></span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><br />Since my REST service returns an xml document all we have to do is store the xml document as an xmltype datatype and use xpath to query the xml document to retrieve the relevant values.<br /><pre><br />select a.xmldataout.extract<br />('//KANSAS_ELEVATION/ELEVATION_LOCATION/ELEVATION_FEET/text()').getNumberVal()<br />as elevation_feet,  <br />a.xmldataout.extract<br />('//KANSAS_ELEVATION/ELEVATION_LOCATION/ELEVATION_METERS/text()').getNumberVal()<br />as elevation_meters<br />from (select<br />xmltype(UTL_HTTP.REQUEST<br />       ('http://geoportal.kgs.ku.edu/kgs/web_services/kansas_elevation/<br />         ks_ned_elevation_datum.cfm?latitude=39.1&longitude=-99.6&amp;datum=27'<br />       )<br />) xmldataout from dual) a<br />where a.xmldataout.extract('//KANSAS_ELEVATION/ERROR/text()').getStringVal() is null<br /></pre><br />Which returns...<br /><span style="font-family:courier new;"><pre>ELEVATION_FEET ELEVATION_METERS<br />-------------- ----------------<br />2886.25208       879.686707</pre></span><br />Do you see the power?  I can do this for single point or as an update to an entire table.<br /><br />So now I can map the elevation along my run route...<br /></span></span><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/run_elevation.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/run_elevation.jpg" alt="" border="0" /></a><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><br /></span></span>";s:4:"link";s:75:"http://geosql.blogspot.com/2006/04/consuming-rest-services-with-oracle.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"0";}s:7:"summary";s:6520:"<span style="color: rgb(0, 0, 0);font-family:arial;" >I love </span><a style="font-family: arial; color: rgb(51, 102, 255);" href="http://webservices.xml.com/pub/a/ws/2002/02/06/rest.html">REST</a><span style="color: rgb(0, 0, 0);font-family:arial;" > services (representation state transfer).   They provide a powerful yet simple way of consuming data via the web (Some examples of REST services:  <a href="http://developer.yahoo.com/search/index.html">Yahoo</a>, some <a href="http://ashburnarcweb.esri.com/v2006/develop/rest.jsp">ArcWeb Services</a>, <a href="http://www.mapdex.org/cfcdoc/mapdex.html">Mapdex API</a>, <a href="http://www.flickr.com/services/api/request.rest.html">Flickr</a>, even <a href="http://portal.opengeospatial.org/files/?artifact_id=14416">WMS </a>services).    Here is an example of one I made up.</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:arial;" >I want to be able to query the National Elevation Dataset (via http://seamless.usgs.gov ) to find out what the elevation is at a particular latitude, longitude coordinate.  I want to submit a geographic point and extract the elevation value at the point.  USGS is publishing this as an ArcIMS image service </span><span style="color: rgb(0, 0, 0);font-family:arial;" >(<a href="http://www.mapdex.org/getserviceinfo_style.cfm?server_id=ortho.cr.usgs.gov&service_name=USGS_EDC_Elev_NED&amp;server_ip=152.61.128.152">USGS_EDC_Elev_NED</a>)</span><span style="color: rgb(0, 0, 0);font-family:arial;" >.     I can use the <a href="http://edndoc.esri.com/arcims/9.1/elements/get_raster_info.htm">get_raster_info</a> request to extract the elevation at a particular point.<br /><br /><a href="http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.cfm?latitude=38&longitude=-115&amp;mapserver=seamless.usgs.gov&mapservice=USGS_EDC_Elev_NED&amp;layer_id=NED.CONUS_NED">Here</a> is my test REST service:</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:arial;" ><pre>http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.cfm?<br />latitude=38&longitude=-115<br />&amp;mapserver=seamless.usgs.gov<br />&mapservice=USGS_EDC_Elev_NED<br />&amp;layer_id=NED.CONUS_NED</pre></span><br /><span style="color: rgb(0, 0, 0);font-family:arial;" ><br />You can view the source code <a href="http://hercules.kgs.ku.edu/kgs/web_services/NED_REST/seamless_ned_elevation.txt">here</a>.<br /><br />It queries the service and reformats the ArcIMS response to the following XML output:</span><br /><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >&lt;NED_ELEVATION&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" > &lt;ELEVATION_LOCATION latitude="38" longitude="-115"&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >   &lt;ELEVATION_METERS&gt;1627.53918457031&lt;/ELEVATION_METERS&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >   &lt;ELEVATION_FEET&gt;5339.95606458&lt;/ELEVATION_FEET&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" > &lt;/ELEVATION_LOCATION&gt;</span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" >&lt;/NED_ELEVATION&gt;</span><span style="color: rgb(0, 0, 0);font-family:courier new;" ><br /><br /><br /><span style="font-family:arial;">In order to access this document in Oracle we need to take advantage of two features.  One is the utl_http package (see <a href="http://asktom.oracle.com/pls/ask/f?p=4950:8:::::F4950_P8_DISPLAYID:285215954607">AskTom</a> or the Oracle docs for more info) to request an html page via a url.<br /><br /></span></span><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/utl_http.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/utl_http.jpg" alt="" border="0" /></a><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><span style="font-family:arial;">This query will actually return the text/xml response from the server as a 4000 character string to the sqlplus window (use request_pieces for larger files).<br /><br /></span><span style="font-family:arial;">We then have to turn this character representation into an xml document so we can query it.<br /><br /></span></span></span><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;">To do this we can use the <a href="http://www.oracle.com/technology/oramag/oracle/01-nov/o61xml.html">xmltype</a> datatype (an Oracle system defined datatype) that allows us to parse an xml document and query it via xpath.</span></span><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><br />Since my REST service returns an xml document all we have to do is store the xml document as an xmltype datatype and use xpath to query the xml document to retrieve the relevant values.<br /><pre><br />select a.xmldataout.extract<br />('//KANSAS_ELEVATION/ELEVATION_LOCATION/ELEVATION_FEET/text()').getNumberVal()<br />as elevation_feet,  <br />a.xmldataout.extract<br />('//KANSAS_ELEVATION/ELEVATION_LOCATION/ELEVATION_METERS/text()').getNumberVal()<br />as elevation_meters<br />from (select<br />xmltype(UTL_HTTP.REQUEST<br />       ('http://geoportal.kgs.ku.edu/kgs/web_services/kansas_elevation/<br />         ks_ned_elevation_datum.cfm?latitude=39.1&longitude=-99.6&amp;datum=27'<br />       )<br />) xmldataout from dual) a<br />where a.xmldataout.extract('//KANSAS_ELEVATION/ERROR/text()').getStringVal() is null<br /></pre><br />Which returns...<br /><span style="font-family:courier new;"><pre>ELEVATION_FEET ELEVATION_METERS<br />-------------- ----------------<br />2886.25208       879.686707</pre></span><br />Do you see the power?  I can do this for single point or as an update to an entire table.<br /><br />So now I can map the elevation along my run route...<br /></span></span><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/run_elevation.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/run_elevation.jpg" alt="" border="0" /></a><br /><span style="color: rgb(0, 0, 0);font-family:courier new;" ><span style="font-family:arial;"><br /></span></span>";}i:2;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-114360359424135551";s:7:"pubdate";s:31:"Wed, 29 Mar 2006 02:39:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-03-28T23:27:00.903-06:00";}s:5:"title";s:39:"Database + GIS = Powerful Visualization";s:11:"description";s:3484:"I love GIS.  Here are two flat Oracle tables one describing the top values (depth to a particular formation) for all the wells in Kansas the other summarizing the amount of production by section (PLSS square mile), by year, by type (oil or gas), and by formation.<br /><pre><br />SQL> desc STRAT_WELL_TOP_22MAR2006<br />Name                               Null?    Type<br />---------------------------------- -------- ------------------<br />FORMATION_NAME                     NOT NULL VARCHAR2(60)<br />WELL_HEADER_KID                    NOT NULL NUMBER(10)<br />WELL_TOP                                    NUMBER(8,2)<br />FIELD_KID                                   NUMBER(10)<br />LATITUDE                                    NUMBER(11,6)<br />LONGITUDE                                   NUMBER(11,6)<br />GROUND_ELEVATION                            VARCHAR2(40)<br />GROUND_ELEVATION_SOURCE                     VARCHAR2(12)<br />WELL_TOP_SEALEVEL_NON_NED                   VARCHAR2(40)<br />WELL_TOP_SEALEVEL                           NUMBER<br /><br />SQL> desc ACRES_640_PRODUCTION_FORMATION<br />Name                                     Null?    Type<br />---------------------------------------- -------- -------------<br />RECNMBR                                  NOT NULL NUMBER(11)<br />STRAT_UNIT_KID                           NOT NULL NUMBER(10)<br />YEAR                                     NOT NULL NUMBER(4)<br />PRODUCT                                  NOT NULL VARCHAR2(1)<br />PRODUCTION                                        NUMBER(12,2)<br /></pre>The goal is to produce a multipatch polygon between two formations colored by the cummulative amount of oil and gas production between the formaitons.  Today I built a geoprocessing model to accomplish this task.   Here are the steps I need to...<br /><br /><ol><li>Select records for two distinct formations,</li><li>Generate event themes based on the x,y coordinates of the records in step 1,</li><li>Generate two distinct TIN representations of the x,y,z values,</li><li>Create a view that summarizes the production between the two formations by section and join that datasaet to a spatial layer depicting the sections,</li><li>Use the <a href="http://edndoc.esri.com/arcobjects/9.1/default.asp?url=/arcobjects/9.1/ComponentHelp/esriGeometry/IExtrude_ExtrudeBetween.htm">extrude between</a> process to generate a multi-patch polygon using the two tin datasets as the top and bottom surfaces clipped by the section production.</li></ol>Anyway enough talk...Here is the model:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/top_extrude_model.jpg"><img style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/top_extrude_model.jpg" alt="" border="0" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />And here is the output...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/view3d.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/view3d.jpg" alt="" border="0" /></a><br /><br />The cool thing about the model is that I can rerun it based on any input query (set of formations).  Build once, run everywhere.<br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:75:"http://geosql.blogspot.com/2006/03/database-gis-powerful-visualization.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"3";}s:7:"summary";s:3484:"I love GIS.  Here are two flat Oracle tables one describing the top values (depth to a particular formation) for all the wells in Kansas the other summarizing the amount of production by section (PLSS square mile), by year, by type (oil or gas), and by formation.<br /><pre><br />SQL> desc STRAT_WELL_TOP_22MAR2006<br />Name                               Null?    Type<br />---------------------------------- -------- ------------------<br />FORMATION_NAME                     NOT NULL VARCHAR2(60)<br />WELL_HEADER_KID                    NOT NULL NUMBER(10)<br />WELL_TOP                                    NUMBER(8,2)<br />FIELD_KID                                   NUMBER(10)<br />LATITUDE                                    NUMBER(11,6)<br />LONGITUDE                                   NUMBER(11,6)<br />GROUND_ELEVATION                            VARCHAR2(40)<br />GROUND_ELEVATION_SOURCE                     VARCHAR2(12)<br />WELL_TOP_SEALEVEL_NON_NED                   VARCHAR2(40)<br />WELL_TOP_SEALEVEL                           NUMBER<br /><br />SQL> desc ACRES_640_PRODUCTION_FORMATION<br />Name                                     Null?    Type<br />---------------------------------------- -------- -------------<br />RECNMBR                                  NOT NULL NUMBER(11)<br />STRAT_UNIT_KID                           NOT NULL NUMBER(10)<br />YEAR                                     NOT NULL NUMBER(4)<br />PRODUCT                                  NOT NULL VARCHAR2(1)<br />PRODUCTION                                        NUMBER(12,2)<br /></pre>The goal is to produce a multipatch polygon between two formations colored by the cummulative amount of oil and gas production between the formaitons.  Today I built a geoprocessing model to accomplish this task.   Here are the steps I need to...<br /><br /><ol><li>Select records for two distinct formations,</li><li>Generate event themes based on the x,y coordinates of the records in step 1,</li><li>Generate two distinct TIN representations of the x,y,z values,</li><li>Create a view that summarizes the production between the two formations by section and join that datasaet to a spatial layer depicting the sections,</li><li>Use the <a href="http://edndoc.esri.com/arcobjects/9.1/default.asp?url=/arcobjects/9.1/ComponentHelp/esriGeometry/IExtrude_ExtrudeBetween.htm">extrude between</a> process to generate a multi-patch polygon using the two tin datasets as the top and bottom surfaces clipped by the section production.</li></ol>Anyway enough talk...Here is the model:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/top_extrude_model.jpg"><img style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/top_extrude_model.jpg" alt="" border="0" /></a><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />And here is the output...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/view3d.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/view3d.jpg" alt="" border="0" /></a><br /><br />The cool thing about the model is that I can rerun it based on any input query (set of formations).  Build once, run everywhere.<br /><br />Cheers,<br /><br />Jeremy";}i:3;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-114287459634169789";s:7:"pubdate";s:31:"Mon, 20 Mar 2006 17:01:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-03-20T11:11:25.543-06:00";}s:5:"title";s:28:"SQL Interpolation Techniques";s:11:"description";s:38991:"First off I have just returned from the ESRI developers summit and I had a great time.  It was so nice to meet all the great developers out there.  ESRI did a great job in organizing it.  If you ever get a chance to meet <a href="http://www.spatialdatalogic.com/cs/blogs/brian_flood/default.aspx">Brian Flood</a> take advantage of it.  Brian is an amazing developer and I really enjoyed our coversations.  Brian gets it...<br /><br />I file this one under, stop me before I try to do too much with SQL!  I wrote this a couple of years ago when I wanted have an interpolation routine that was straight SQL (No Oracle Spatial and No SDE).  I would not do this technique now (ESRI Spatial Type for Oracle or straight to ArcGIS Server for my interpolations) but it illustrates some good Analytical Function practices.  Enjoy...<br /><br /><PRE>ORIGINAL QUESTION:<br /><br />I have a table that represents one mile polygons (sections) that has locational <br />information, center latitude and center longitude.  I have another table that is <br />made up of point data that has for every point the latitude, longitude, and some<br />value (lets say it is a water level depth).  What I want to do is build a view <br />that has the section polygon ID and an average water level value for the closest <br />10 wells that are at least within 10 square miles.  This involves computing the <br />distance of all wells within a 10 square mile of the polygon cell, sorting those <br />wells to find the closest 10, and then averaging the results (actually I would <br />perform some kind of inverse distance calculation, but for simplicity sake I <br />would like to see how you would  efficiently select and average the 10 wells <br />values). <br /><br /><br />I HAVE PASTED MY ATTEMPT BELOW...<br /><br />HERE IS INFORMATION ABOUT THE TWO TABLES THAT QUERY USES.  <br /><br /><br />SQL> DESC ACRES640_XYCENTER<br /> Name                                      Null?    Type<br /> ----------------------------------------- -------- ----------------------------<br /> OBJECTID                                  NOT NULL NUMBER(38)<br /> TRS                                                VARCHAR2(10)<br /> RECNMBR                                            NUMBER(11)<br /> CENTER_X                                           NUMBER(23,11)<br /> CENTER_Y                                           NUMBER(23,11)<br /> SHAPE                                              NUMBER(38)<br /><br />SQL> select trs, recnmbr, center_x, center_y from ACRES640_XYCENTER where rownum < 10;<br /><br />TRS           RECNMBR   CENTER_X   CENTER_Y                                     <br />---------- ---------- ---------- ----------                                     <br />02S22W08         2816    -133815     431037                                     <br />02S05E07         2817     114097     430710                                     <br />02S12E07         2818     181440     431992                                     <br />02S03W08         2819    48505.5     430018                                     <br />02S23W12         2820    -136969     431089                                     <br />02S05W08         2821 29424.6992     429929                                     <br />02S04E12         2822     112494     430684                                     <br />02S25W10         2823    -159307     431515                                     <br />02S10E07         2824     162297     431573                                     <br /><br />9 rows selected.<br /><br /><br />SQL> SELECT COUNT(*) FROM ACRES640_XYCENTER;<br /><br />  COUNT(*)                                                                      <br />----------                                                                      <br />     81803                                                                      <br /><br /><br />SQL> desc WELLHEADERS_25MAY2004_PRJ<br /> Name                                      Null?    Type<br /> ----------------------------------------- -------- ----------------------------<br /> OBJECTID                                  NOT NULL NUMBER(38)<br /> KID                                                NUMBER(10)<br /> LATITUDE                                           NUMBER(17,6)<br /> LONGITUDE                                          NUMBER(17,6)<br /> X_COORD                                            NUMBER(23,11)<br /> Y_COORD                                            NUMBER(23,11)<br /> SHAPE                                              NUMBER(38)<br /><br />     <br /><br />SQL> select kid, latitude, longitude, x_coord, y_coord from WELLHEADERS_25MAY2004_PRJ;<br /><br />       KID   LATITUDE  LONGITUDE    X_COORD    Y_COORD                          <br />---------- ---------- ---------- ---------- ----------                          <br />1027937589   37.00094  -95.77342     219360     113565                          <br />1027937587   37.00094  -95.77342     219360     113565                          <br />1027937585   37.00094  -95.77342     219360     113565                          <br />1027937583   37.00094  -95.77342     219360     113565                          <br />1027937567   37.00094  -95.77342     219360     113565                          <br />1027937237   37.00094  -95.77342     219360     113565                          <br />1027937235   37.00094  -95.77342     219360     113565                          <br />1027935075   37.00094  -95.77342     219360     113565                          <br />1027803979   37.00094  -95.77342     219360     113565                          <br />1027936869   37.00094  -95.77342     219360     113565                          <br />1027936867   37.00094  -95.77342     219360     113565                          <br />1027936865   37.00094  -95.77342     219360     113565                          <br />1027936805   37.00094  -95.77342     219360     113565                          <br />1027937057   37.00094  -95.77342     219360     113565                          <br />1027934581   37.00094  -95.77342     219360     113565                          <br />1027934579   37.00094  -95.77342     219360     113565                          <br />1027934577   37.00094  -95.77342     219360     113565                          <br />1027934575   37.00094  -95.77342     219360     113565                          <br />1027934573   37.00094  -95.77342     219360     113565                          <br />1027934571   37.00094  -95.77342     219360     113565                          <br />1027934569   37.00094  -95.77342     219360     113565                          <br />1027804273   37.00094  -95.77342     219360     113565                          <br />1027804269   37.00094  -95.77342     219360     113565                          <br />1006790617   37.00133  -96.08868     191441     112895                          <br />1002895443   37.00133  -96.21841     179952     112630                          <br />1006790402   37.00133  -96.21841     179952     112630                          <br />1001257052   37.00132 -101.97293    -329700     117372                          <br />1006094323   37.00132 -101.97293    -329700     117372                          <br />1006094606   37.00132 -101.97746    -330101     117389                          <br />1020067001   37.00132 -101.97746    -330101     117389                          <br />1005449837   37.00132 -101.97746    -330101     117389                          <br />1026090216    37.0013 -100.57895    -206286     113259                          <br />1006093808    37.0013 -100.57895    -206286     113259                          <br />1026525325    37.0013 -100.57895    -206286     113259                          <br />1027805483   37.00128  -95.84634     212901     113429                          <br />1027937579   37.00128  -95.84634     212901     113429                          <br />1027807657   37.00128  -95.84634     212901     113429                          <br />1027807573   37.00128  -95.84634     212901     113429                          <br />1027807185   37.00128  -95.84634     212901     113429                          <br />1027703233   37.00128  -98.83632 -51938.301     110781                          <br />1027796075   37.00128  -98.83632 -51938.301     110781                          <br />1002901280   37.00127  -97.07416     104158     111286                          <br />1008415306   37.00127 -101.51646    -289294     115812                          <br />1027807735   37.00122  -95.82817     214511     113465                          <br />1027805485   37.00122  -95.82817     214511     113465                          <br />1027807499   37.00122  -95.82817     214511     113465                          <br />1027806799   37.00122  -95.82817     214511     113465                          <br />1027806797   37.00122  -95.82817     214511     113465                          <br />1027806517   37.00122  -95.82817     214511     113465                          <br />1027805877   37.00122  -95.82817     214511     113465                          <br />1006143725   37.00122 -100.71236    -218100     113562                          <br />1002932550    37.0012  -95.81286     215866     113499                          <br />1006790987   37.00119  -95.80991     216128     113505                          <br />1005456974   37.00119  -95.80991     216128     113505                          <br />1027805555   37.00119  -95.80992     216127     113505                          <br />1006790391   37.00111  -96.19579     181955     112651                          <br />1002895619   37.00111  -96.41649     162409     112233                          <br />1006790787    37.0011   -95.9109     207185     113260                          <br />1027805141   37.00109  -95.79157     217752     113538                          <br />1027805077   37.00109  -95.79157     217752     113538                          <br />1027931973   37.00109  -95.79157     217752     113538                          <br />1027931971   37.00109  -95.79157     217752     113538                          <br />1027806551   37.00109  -95.79157     217752     113538                          <br />1004751365   37.00159 -101.81951    -316120     116857                          <br />1002876182   37.00159 -101.82404    -316521     116873                          <br />1002895677   37.00158  -96.26826     175536     112560                          <br />1002952960   37.00158  -97.65121 53042.6992     110821                          <br /><br />68 rows selected.<br /><br /><br /><br />SQL> SELECT COUNT(*) FROM WELLHEADERS_25MAY2004_PRJ;<br /><br />  COUNT(*)                                                                      <br />----------                                                                      <br />    375571                                                                      <br /><br /><br />SQL> <br />SQL> COLUMN COLUMN_NAME FORMAT A15 TRUNC<br />SQL> ;<br />  1  SELECT INDEX_NAME, COLUMN_NAME, TABLE_NAME FROM USER_IND_COLUMNS<br />  2* WHERE TABLE_NAME IN ('WELLHEADERS_25MAY2004_PRJ','ACRES640_XYCENTER')<br />SQL> /<br /><br />INDEX_NAME                     COLUMN_NAME     TABLE_NAME                       <br />------------------------------ --------------- ------------------------------   <br />A1411_IX1                      SHAPE           ACRES640_XYCENTER                <br />R2067_SDE_ROWID_UK             OBJECTID        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_RECNMBR      RECNMBR         ACRES640_XYCENTER                <br />ACRES640_XYCENTER_X_YCENT      CENTER_X        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_X_YCENT      CENTER_Y        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_CENTX        CENTER_X        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_CENTY        CENTER_Y        ACRES640_XYCENTER                <br />A1409_IX1                      SHAPE           WELLHEADERS_25MAY2004_PRJ        <br />R2065_SDE_ROWID_UK             OBJECTID        WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004KID      KID             WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_LATLONG Y_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_LATLONG X_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_YCOORD  Y_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_XCOORD  X_COORD         WELLHEADERS_25MAY2004_PRJ        <br /><br />14 rows selected.<br /><br />                                               <br /><br /><br />HERE IS THE QUERY THAT I CAME UP WITH....<br /><br /><br /><br />FIRST I WANT TO SELECT THE SECTION ID, WELL ID, THE DISTANCE FROM THE WELL TO THE <br />CENTER OF THE SECTION, & THE QUADRANT OF THE SECTION (NW,NE,SW,SE) THAT THE WELL<br />IS IN ALL WITHIN A 7200 X 7200 METER BOUDING BOX (CENTERED ON THE SECTION CENTER) <br />FOR EVERY SECTION IN MY STUDY AREA.  <br /><br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /><br /><br /><br /><br />   RECNMBR        KID QU DISTANCE_TO_CELL<br />---------- ---------- -- ----------------<br />     49950 1006068633 SW       4129.70144<br />     49950 1006068137 SW       3580.94959<br />     49950 1002919963 SW       4519.08055<br />     49950 1006068032 SE       3446.22605<br />     49950 1006068206 SW       2316.18501<br />     49950 1022362561 SW       3422.35124<br />     49950 1006068139 SW       1594.49365<br />     49950 1001235397 SW       3128.24951<br />     49950 1022009618 SW       2460.49934<br />     49950 1006068479 SW       1646.93169<br />     49950 1006068208 SW       2039.86985<br />     49950 1026642145 NW       2022.24281<br />     49950 1025778509 NW       2062.54042<br />     49950 1025686933 NW       3158.56803<br />     49950 1022362563 NW       3747.38909<br />     49950 1006068200 NW       3791.15352<br />     49950 1022009617 NW       2596.05951<br />     49950 1020066904 NW       3337.37142<br />     49950 1006068395 NW       4568.36393<br />     49952 1006068633 SW       3628.02563<br />     49952 1006068437 SW        4142.8273<br />     49952 1006068137 SW       3201.38033<br />     49952 1002919963 SW        3479.8352<br />     49952 1008378808 SW       4545.26149<br />     49952 1002920004 SW       4531.73697<br />     49952 1008764319 SW       3459.29299<br />     49952 1006068206 SE       2021.65502<br />     49952 1022362561 SW         2330.793<br />     49952 1006067823 SW       2810.31617<br />     49952 1002919902 SW       3859.54661<br />     49952 1006068139 SE       2240.00223<br />     49952 1001235397 SW       1855.94854<br />     49952 1022009618 SW       1463.18591<br />     49952 1006068585 SW       2491.16539<br />     49952 1006068479 SE       1237.73503<br />     49952 1006068381 SW       3055.63512<br />     49952 1027708907 SW       3536.07494<br />     49952 1006067716 SW       2673.85303<br />     49952 1006068208 SW       558.660004<br />     49952 1006067854 SW       2193.10054<br />     49952 1026642145 NW       435.910541<br />     49952 1025778509 NW       603.927976<br />     49952 1002919979 NW       2058.37266<br />     49952 1025686933 NW       1719.64764<br />     49952 1022362563 NW       2248.00022<br />     49952 1006068200 NW       2332.77196<br />     49952 1006068683 NW       3040.36527<br />     49952 1006067983 NW       3812.09299<br />     49952 1022009617 NW       1515.13201<br />     49952 1020066904 NW       2175.32802<br /><br />THEN I USE THE ANALYTICAL FUNCTION DENSE_RANK TO ASSIGN A RANKING VALUE FOR <br />THE DISTANCE BY SECTION NUMBER (RECNMBR) TO EACH WELL<br /><br />select recnmbr, kid, quadrant, distance_to_cell,         <br /> dense_rank()<br />       over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />from (       <br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /> )<br />   <br />   <br /><br /><br />   RECNMBR        KID QU DISTANCE_TO_CELL TOPN_TOTAL<br />---------- ---------- -- ---------------- ----------   <br />     49948 1006068139 SW       2280.82989          1<br />     49948 1006068032 SE       2320.57859          2<br />     49948 1006068479 SW        3008.3173          3<br />     49948 1006068206 SW       3434.70581          4<br />     49948 1006068198 SE       3514.10543          5<br />     49948 1006067819 NE       4519.37982          6<br />     49948 1006068137 SW       4533.81749          7<br />     49948 1006068188 SE       4542.85417          8<br />     49950 1006068139 SW       1594.49365          1<br />     49950 1006068479 SW       1646.93169          2<br />     49950 1026642145 NW       2022.24281          3<br />     49950 1006068208 SW       2039.86985          4<br />     49950 1025778509 NW       2062.54042          5<br />     49950 1006068206 SW       2316.18501          6<br />     49950 1022009618 SW       2460.49934          7<br />     49950 1022009617 NW       2596.05951          8<br />     49950 1001235397 SW       3128.24951          9<br />     49950 1025686933 NW       3158.56803         10<br />     49950 1020066904 NW       3337.37142         11<br />     49950 1022362561 SW       3422.35124         12<br />     49950 1006068032 SE       3446.22605         13<br />     49950 1006068137 SW       3580.94959         14<br />     49950 1022362563 NW       3747.38909         15<br />     49950 1006068200 NW       3791.15352         16<br />     49950 1006068633 SW       4129.70144         17<br />     49950 1002919963 SW       4519.08055         18<br />     49950 1006068395 NW       4568.36393         19<br />     49952 1026642145 NW       435.910541          1<br />     49952 1006068208 SW       558.660004          2<br />     49952 1025778509 NW       603.927976          3<br />     49952 1006068479 SE       1237.73503          4<br />     49952 1022009618 SW       1463.18591          5<br />     49952 1022009617 NW       1515.13201          6<br />     49952 1025686933 NW       1719.64764          7<br />     49952 1001235397 SW       1855.94854          8<br />     49952 1006068206 SE       2021.65502          9<br />     49952 1002919979 NW       2058.37266         10<br />     49952 1020066904 NW       2175.32802         11<br />     49952 1006067854 SW       2193.10054         12<br />     49952 1006068139 SE       2240.00223         13<br />     49952 1022362563 NW       2248.00022         14<br />     49952 1022362561 SW         2330.793         15<br />     49952 1006068200 NW       2332.77196         16<br />     49952 1006068585 SW       2491.16539         17<br />     49952 1006067716 SW       2673.85303         18<br />     49952 1006067823 SW       2810.31617         19<br />     49952 1006068683 NW       3040.36527         20<br />     49952 1006068381 SW       3055.63512         21<br />     49952 1006068137 SW       3201.38033         22<br />     49952 1006068395 NW       3454.67292         23<br />     49952 1008764319 SW       3459.29299         24<br />     49952 1002919963 SW        3479.8352         25<br />     49952 1027708907 SW       3536.07494         26<br />     49952 1006068633 SW       3628.02563         27<br />     49952 1006067983 NW       3812.09299         28<br />     49952 1002919902 SW       3859.54661         29<br />     49952 1013358575 NW       3955.73204         30<br />     49952 1006068437 SW        4142.8273         31<br />     49952 1002920004 SW       4531.73697         32<br />     49952 1008378808 SW       4545.26149         33   <br />     <br />     <br />NEXT WE SELECT THE 8 CLOSEST WELLS FOR EACH SECTION, WE ALSO NEED TO COMPUTE<br />THE COUNT OF THE DISTINCT QUADRANTS.  WE NEED THIS BECAUSE SOME INTERPOLATION <br />TECHNIQUES WORK BETTER IF YOU FORCE THE INTERPOLATED VALUE TO HAVE AT LEAST X <br />NUMBER OF POINTS IN EACH QUADRANT.  IN THIS CASE WE ARE GOING TO WANT TO HAVE <br />AT LEAST ONE WELL IN EACH QUADRANT.<br /><br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL, <br />count(distinct QUADRANT) over (partition by recnmbr) QUAD_COUNT<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />select recnmbr, kid, quadrant, distance_to_cell,<br /> dense_rank()<br />       over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />from (       <br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /> )<br />)<br />where TOPN_TOTAL <= 8<br />)<br />        <br />        <br />   RECNMBR        KID DISTANCE_TO_CELL QU TOPN_TOTAL QUAD_COUNT<br />---------- ---------- ---------------- -- ---------- ----------<br />     49934 1006068645           1800.1 NE          1          3<br />     49934 1006068218       2281.36122 NE          3          3<br />     49934 1006068541       3524.63587 NW          6          3<br />     49934 1006068571        3722.9722 NW          7          3<br />     49934 1006068190       1808.89607 SW          2          3<br />     49934 1006068182       2839.38479 SW          4          3<br />     49934 1006068198       3833.55879 SW          8          3<br />     49934 1006068545       2948.63036 SW          5          3<br />     49935 1006068645       513.778162 NE          1          4<br />     49935 1006079840       4155.58817 NE          7          4<br />     49935 1006068218       1812.26185 NW          2          4<br />     49935 1006068541       4270.07283 NW          8          4<br />     49935 1027709052       3397.06712 SE          3          4<br />     49935 1023930739       3397.06712 SE          3          4<br />     49935 1006068190       3402.91713 SW          4          4<br />     49935 1006068545       3581.14074 SW          5          4<br />     49935 1006068182       4043.25834 SW          6          4<br />     49937 1001243091       2834.38124 NE          1          4<br />     49937 1006344036        3447.8283 NE          6          4<br />     49937 1006068645       3079.22019 NW          3          4<br />     49937 1006079840       3140.74704 NW          4          4<br />     49937 1006068218       3822.73018 NW          8          4<br />     49937 1006078290       3037.51165 SE          2          4<br />     49937 1006078651       3798.06859 SE          7          4<br />     49937 1027709052       3203.50433 SW          5          4<br />     49937 1023930739       3203.50433 SW          5          4<br />     49938 1006079840       3328.76974 NE          4          3<br />     49938 1006344036       4377.68249 NE          7          3<br />     49938 1001243091       3437.66912 NE          5          3<br />     49938 1006068645       1535.64091 NW          1          3<br />     49938 1006068218       2537.84357 NW          2          3<br />     49938 1027709052       2893.72839 SE          3          3<br />     49938 1006078290       3944.43317 SE          6          3<br />     49938 1023930739       2893.72839 SE          3          3        <br /><br /><br />FINALLY WE SELECT ALL SECTIONS THAT HAVE A DISTINCT QUAD COUNT OF 4.  <br />THE 8 CLOSEST WELLS THAT HAVE AT LEAST ONE WELL IN EACH QUADRANT.<br /><br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL, <br />count(distinct QUADRANT) over (partition by recnmbr) QUAD_COUNT<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />  select recnmbr, kid, quadrant, distance_to_cell,<br />  dense_rank()<br />        over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />    from (       <br />   select a.recnmbr recnmbr, b.kid kid,<br />     case <br />     when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />     when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />     when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />     when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />      end QUADRANT,<br />   sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />       ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />     from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />    where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />      and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />      and a.center_x >= -320688<br />      and a.center_x <= -284100<br />      and a.center_y >= 169518<br />      and a.center_y <= 242855 <br />  )<br /> )<br />where TOPN_TOTAL <= 8<br />)<br />)<br />where QUAD_COUNT = 4<br /><br />   RECNMBR        KID DISTANCE_TO_CELL QU TOPN_TOTAL                            <br />---------- ---------- ---------------- -- ----------                            <br />     49935 1006068645       513.778162 NE          1                            <br />     49935 1006079840       4155.58817 NE          7                            <br />     49935 1006068218       1812.26185 NW          2                            <br />     49935 1006068541       4270.07283 NW          8                            <br />     49935 1027709052       3397.06712 SE          3                            <br />     49935 1023930739       3397.06712 SE          3                            <br />     49935 1006068190       3402.91713 SW          4                            <br />     49935 1006068545       3581.14074 SW          5                            <br />     49935 1006068182       4043.25834 SW          6                            <br />     49937 1001243091       2834.38124 NE          1                            <br />     49937 1006344036        3447.8283 NE          6                            <br />     49937 1006068645       3079.22019 NW          3                            <br />     49937 1006079840       3140.74704 NW          4                            <br />     49937 1006068218       3822.73018 NW          8                            <br />     49937 1006078290       3037.51165 SE          2                            <br />     49937 1006078651       3798.06859 SE          7                            <br />     49937 1027709052       3203.50433 SW          5                            <br />     49937 1023930739       3203.50433 SW          5                            <br />     49942 1006068571        3908.5835 NE          7                            <br />     49942 1006067819       3588.20693 NW          6                            <br />     49942 1006068190       1423.03127 SE          1                            <br />     49942 1006068545       3960.37902 SE          8                            <br />     49942 1006068182       2597.02849 SE          3                            <br />     49942 1006068198       1792.30578 SW          2                            <br />     49942 1006068032       2809.95267 SW          4                            <br />     49942 1006068188       3394.99411 SW          5                            <br />     49960 1025686933       1021.17188 NE          3                            <br />     49960 1025778509       1262.06537 NE          8                            <br />     49960 1026642145       1187.63041 NE          6                            <br />     49960 1002919979       575.591869 NW          1                            <br />     49960 1022362563       1078.89063 NW          4                            <br />     49960 1006068208       1259.78292 SE          7                            <br />     49960 1006067854       595.014286 SW          2                            <br />     49960 1006067716       1167.87414 SW          5                            <br />     49965 1006068379       573.098595 NE          3                            <br />     49965 1006067673       1086.42993 NE          6                            <br />     49965 1022362558       591.472738 NW          4                            <br />     49965 1026642147       1239.35548 NW          7                            <br />     49965 1021121940       1074.38029 SE          5                            <br />     49965 1006068265       1253.18953 SE          8                            <br />     49965 1002919999        276.06521 SW          1                            <br />     49965 1025777349       300.026665 SW          2                            <br />     49966 1006068143       574.381406 NE          5                            <br />     49966 1006067881       1014.58563 NE          7                            <br />     49966 1002919986       572.856876 NW          4                            <br />     49966 1002919921       277.200289 SE          1                            <br />     49966 1008378793       280.189222 SE          2                            <br />     49966 1001235373       589.896601 SE          6                            <br />     49966 1006068265       557.917557 SW          3                            <br />     49966 1021121940       1121.31396 SW          8                            <br />     49969 1002919979       1253.72166 NE          8                            <br />     49969 1022362560       608.152941 NW          3                            <br />     49969 1006067716       855.977803 SE          4                            <br />     49969 1006067854       1024.65311 SE          5                            <br />     49969 1008378866        566.39209 SW          1                            <br />     49969 1027708907       1095.42777 SW          6                            <br />     49969 1001235373        1251.9976 SW          7                            <br />     49969 1027625616       591.959458 SW          2                            <br />     49979 1006068577       531.497883 NE          3                            <br />     49979 1006068477        1251.4128 NE          6                            <br />     49979 1006068591       1255.48755 NW          7                            <br />     49979 1013358584        614.18564 SE          4                            <br />     49979 1019411297       1270.18739 SE          8                            <br />     49979 1006812097       280.189222 SW          1                            <br />     49979 1006067545       282.242803 SW          2                            <br />     49979 1006068726       1042.14826 SW          5                            <br />AND ON AND ON....                        <br />     68143 1028445209       1044.73585 NE          2                            <br />     68143 1002950389       1708.98391 NE          5                            <br />     68143 1006155639       2714.99411 NE          8                            <br />     68143 1025830097       1073.93203 NE          3                            <br />     68143 1006154723       574.464968 NW          1                            <br />     68143 1002950475       2615.97898 SE          7                            <br />     68143 1006155021       1442.30718 SW          4                            <br />     68143 1028445211       1994.58467 SW          6                            <br />     68167 1006155879       1637.48099 NE          5                            <br />     68167 1001322873       1704.43246 NE          6                            <br />     68167 1022009791       1951.95722 NW          8                            <br />     68167 1006154897       1160.19007 SE          1                            <br />     68167 1002950448       1427.05431 SE          3                            <br />     68167 1006154895         1501.003 SE          4                            <br />     68167 1006155257       1385.55873 SW          2                            <br />     68167 1025830091       1778.85188 SW          7                            <br />     68184 1006155899       618.684087 NE          2                            <br />     68184 1006155931       1399.38915 NE          3                            <br />     68184 1006154883       1695.66329 NE          8                            <br />     68184 1006154895        1690.6274 NW          6                            <br />     68184 1004752885       1492.82618 SE          4                            <br />     68184 1027709638       1693.48664 SE          7                            <br />     68184 1004752884        13.892444 SW          1                            <br />     68184 1004752837       1620.26448 SW          5                            <br />     68187 1006154875       1567.44537 NE          3                            <br />     68187 1006155899       2200.32952 NE          7                            <br />     68187 1006154895       101.828287 NW          1                            <br />     68187 1006155879       1575.13079 NW          4                            <br />     68187 1001322873       2265.00618 NW          8                            <br />     68187 1006154897       423.398158 NW          2                            <br />     68187 1004752884       1595.49271 SE          5                            <br />     68187 1002950448       1993.30304 SW          6                            <br /><br />4396 rows selected.<br /><br />Elapsed: 00:00:25.04<br /><br />Execution Plan<br />----------------------------------------------------------                      <br />   0      SELECT STATEMENT Optimizer=CHOOSE (Cost=1402 Card=2330 Bytes          <br />          =160770)                                                              <br />                                                                                <br />   1    0   VIEW (Cost=1402 Card=2330 Bytes=160770)                             <br />   2    1     WINDOW (SORT) (Cost=1402 Card=2330 Bytes=130480)                  <br />   3    2       VIEW (Cost=1329 Card=2330 Bytes=130480)                         <br />   4    3         WINDOW (SORT PUSHED RANK) (Cost=1329 Card=2330 Bytes          <br />          =69900)                                                               <br />                                                                                <br />   5    4           TABLE ACCESS (BY INDEX ROWID) OF 'WELLHEADERS_25MA          <br />          Y2004_PRJ' (Cost=2 Card=2 Bytes=32)                                   <br />                                                                                <br />   6    5             NESTED LOOPS (Cost=1264 Card=2330 Bytes=69900)            <br />   7    6               TABLE ACCESS (FULL) OF 'ACRES640_XYCENTER' (Co          <br />          st=72 Card=993 Bytes=13902)                                           <br />                                                                                <br />   8    6               INDEX (RANGE SCAN) OF 'WELLHEADERS_25_MAY2004_          <br />          LATLONG' (NON-UNIQUE) (Cost=6 Card=1690)                              <br />                                                                                <br /><br /><br /><br /><br />Statistics<br />----------------------------------------------------------                      <br />          0  recursive calls                                                    <br />          4  db block gets                                                      <br />      65267  consistent gets                                                    <br />        142  physical reads                                                     <br />          0  redo size                                                          <br />     183474  bytes sent via SQL*Net to client                                   <br />       2326  bytes received via SQL*Net from client                             <br />        295  SQL*Net roundtrips to/from client                                  <br />          0  sorts (memory)                                                     <br />          2  sorts (disk)                                                       <br />       4396  rows processed                                                     <br /><br />SQL> <br /><br /><br />THE NEXT STEP WOULD BE ACTUALLY DO THE INTERPOLATION....AVERAGE SOME VALUE WHERE <br />WELL KID = QUERY FROM ABOVE....</PRE><br /><br />Questions/Comments?  <br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:68:"http://geosql.blogspot.com/2006/03/sql-interpolation-techniques.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"0";}s:7:"summary";s:38991:"First off I have just returned from the ESRI developers summit and I had a great time.  It was so nice to meet all the great developers out there.  ESRI did a great job in organizing it.  If you ever get a chance to meet <a href="http://www.spatialdatalogic.com/cs/blogs/brian_flood/default.aspx">Brian Flood</a> take advantage of it.  Brian is an amazing developer and I really enjoyed our coversations.  Brian gets it...<br /><br />I file this one under, stop me before I try to do too much with SQL!  I wrote this a couple of years ago when I wanted have an interpolation routine that was straight SQL (No Oracle Spatial and No SDE).  I would not do this technique now (ESRI Spatial Type for Oracle or straight to ArcGIS Server for my interpolations) but it illustrates some good Analytical Function practices.  Enjoy...<br /><br /><PRE>ORIGINAL QUESTION:<br /><br />I have a table that represents one mile polygons (sections) that has locational <br />information, center latitude and center longitude.  I have another table that is <br />made up of point data that has for every point the latitude, longitude, and some<br />value (lets say it is a water level depth).  What I want to do is build a view <br />that has the section polygon ID and an average water level value for the closest <br />10 wells that are at least within 10 square miles.  This involves computing the <br />distance of all wells within a 10 square mile of the polygon cell, sorting those <br />wells to find the closest 10, and then averaging the results (actually I would <br />perform some kind of inverse distance calculation, but for simplicity sake I <br />would like to see how you would  efficiently select and average the 10 wells <br />values). <br /><br /><br />I HAVE PASTED MY ATTEMPT BELOW...<br /><br />HERE IS INFORMATION ABOUT THE TWO TABLES THAT QUERY USES.  <br /><br /><br />SQL> DESC ACRES640_XYCENTER<br /> Name                                      Null?    Type<br /> ----------------------------------------- -------- ----------------------------<br /> OBJECTID                                  NOT NULL NUMBER(38)<br /> TRS                                                VARCHAR2(10)<br /> RECNMBR                                            NUMBER(11)<br /> CENTER_X                                           NUMBER(23,11)<br /> CENTER_Y                                           NUMBER(23,11)<br /> SHAPE                                              NUMBER(38)<br /><br />SQL> select trs, recnmbr, center_x, center_y from ACRES640_XYCENTER where rownum < 10;<br /><br />TRS           RECNMBR   CENTER_X   CENTER_Y                                     <br />---------- ---------- ---------- ----------                                     <br />02S22W08         2816    -133815     431037                                     <br />02S05E07         2817     114097     430710                                     <br />02S12E07         2818     181440     431992                                     <br />02S03W08         2819    48505.5     430018                                     <br />02S23W12         2820    -136969     431089                                     <br />02S05W08         2821 29424.6992     429929                                     <br />02S04E12         2822     112494     430684                                     <br />02S25W10         2823    -159307     431515                                     <br />02S10E07         2824     162297     431573                                     <br /><br />9 rows selected.<br /><br /><br />SQL> SELECT COUNT(*) FROM ACRES640_XYCENTER;<br /><br />  COUNT(*)                                                                      <br />----------                                                                      <br />     81803                                                                      <br /><br /><br />SQL> desc WELLHEADERS_25MAY2004_PRJ<br /> Name                                      Null?    Type<br /> ----------------------------------------- -------- ----------------------------<br /> OBJECTID                                  NOT NULL NUMBER(38)<br /> KID                                                NUMBER(10)<br /> LATITUDE                                           NUMBER(17,6)<br /> LONGITUDE                                          NUMBER(17,6)<br /> X_COORD                                            NUMBER(23,11)<br /> Y_COORD                                            NUMBER(23,11)<br /> SHAPE                                              NUMBER(38)<br /><br />     <br /><br />SQL> select kid, latitude, longitude, x_coord, y_coord from WELLHEADERS_25MAY2004_PRJ;<br /><br />       KID   LATITUDE  LONGITUDE    X_COORD    Y_COORD                          <br />---------- ---------- ---------- ---------- ----------                          <br />1027937589   37.00094  -95.77342     219360     113565                          <br />1027937587   37.00094  -95.77342     219360     113565                          <br />1027937585   37.00094  -95.77342     219360     113565                          <br />1027937583   37.00094  -95.77342     219360     113565                          <br />1027937567   37.00094  -95.77342     219360     113565                          <br />1027937237   37.00094  -95.77342     219360     113565                          <br />1027937235   37.00094  -95.77342     219360     113565                          <br />1027935075   37.00094  -95.77342     219360     113565                          <br />1027803979   37.00094  -95.77342     219360     113565                          <br />1027936869   37.00094  -95.77342     219360     113565                          <br />1027936867   37.00094  -95.77342     219360     113565                          <br />1027936865   37.00094  -95.77342     219360     113565                          <br />1027936805   37.00094  -95.77342     219360     113565                          <br />1027937057   37.00094  -95.77342     219360     113565                          <br />1027934581   37.00094  -95.77342     219360     113565                          <br />1027934579   37.00094  -95.77342     219360     113565                          <br />1027934577   37.00094  -95.77342     219360     113565                          <br />1027934575   37.00094  -95.77342     219360     113565                          <br />1027934573   37.00094  -95.77342     219360     113565                          <br />1027934571   37.00094  -95.77342     219360     113565                          <br />1027934569   37.00094  -95.77342     219360     113565                          <br />1027804273   37.00094  -95.77342     219360     113565                          <br />1027804269   37.00094  -95.77342     219360     113565                          <br />1006790617   37.00133  -96.08868     191441     112895                          <br />1002895443   37.00133  -96.21841     179952     112630                          <br />1006790402   37.00133  -96.21841     179952     112630                          <br />1001257052   37.00132 -101.97293    -329700     117372                          <br />1006094323   37.00132 -101.97293    -329700     117372                          <br />1006094606   37.00132 -101.97746    -330101     117389                          <br />1020067001   37.00132 -101.97746    -330101     117389                          <br />1005449837   37.00132 -101.97746    -330101     117389                          <br />1026090216    37.0013 -100.57895    -206286     113259                          <br />1006093808    37.0013 -100.57895    -206286     113259                          <br />1026525325    37.0013 -100.57895    -206286     113259                          <br />1027805483   37.00128  -95.84634     212901     113429                          <br />1027937579   37.00128  -95.84634     212901     113429                          <br />1027807657   37.00128  -95.84634     212901     113429                          <br />1027807573   37.00128  -95.84634     212901     113429                          <br />1027807185   37.00128  -95.84634     212901     113429                          <br />1027703233   37.00128  -98.83632 -51938.301     110781                          <br />1027796075   37.00128  -98.83632 -51938.301     110781                          <br />1002901280   37.00127  -97.07416     104158     111286                          <br />1008415306   37.00127 -101.51646    -289294     115812                          <br />1027807735   37.00122  -95.82817     214511     113465                          <br />1027805485   37.00122  -95.82817     214511     113465                          <br />1027807499   37.00122  -95.82817     214511     113465                          <br />1027806799   37.00122  -95.82817     214511     113465                          <br />1027806797   37.00122  -95.82817     214511     113465                          <br />1027806517   37.00122  -95.82817     214511     113465                          <br />1027805877   37.00122  -95.82817     214511     113465                          <br />1006143725   37.00122 -100.71236    -218100     113562                          <br />1002932550    37.0012  -95.81286     215866     113499                          <br />1006790987   37.00119  -95.80991     216128     113505                          <br />1005456974   37.00119  -95.80991     216128     113505                          <br />1027805555   37.00119  -95.80992     216127     113505                          <br />1006790391   37.00111  -96.19579     181955     112651                          <br />1002895619   37.00111  -96.41649     162409     112233                          <br />1006790787    37.0011   -95.9109     207185     113260                          <br />1027805141   37.00109  -95.79157     217752     113538                          <br />1027805077   37.00109  -95.79157     217752     113538                          <br />1027931973   37.00109  -95.79157     217752     113538                          <br />1027931971   37.00109  -95.79157     217752     113538                          <br />1027806551   37.00109  -95.79157     217752     113538                          <br />1004751365   37.00159 -101.81951    -316120     116857                          <br />1002876182   37.00159 -101.82404    -316521     116873                          <br />1002895677   37.00158  -96.26826     175536     112560                          <br />1002952960   37.00158  -97.65121 53042.6992     110821                          <br /><br />68 rows selected.<br /><br /><br /><br />SQL> SELECT COUNT(*) FROM WELLHEADERS_25MAY2004_PRJ;<br /><br />  COUNT(*)                                                                      <br />----------                                                                      <br />    375571                                                                      <br /><br /><br />SQL> <br />SQL> COLUMN COLUMN_NAME FORMAT A15 TRUNC<br />SQL> ;<br />  1  SELECT INDEX_NAME, COLUMN_NAME, TABLE_NAME FROM USER_IND_COLUMNS<br />  2* WHERE TABLE_NAME IN ('WELLHEADERS_25MAY2004_PRJ','ACRES640_XYCENTER')<br />SQL> /<br /><br />INDEX_NAME                     COLUMN_NAME     TABLE_NAME                       <br />------------------------------ --------------- ------------------------------   <br />A1411_IX1                      SHAPE           ACRES640_XYCENTER                <br />R2067_SDE_ROWID_UK             OBJECTID        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_RECNMBR      RECNMBR         ACRES640_XYCENTER                <br />ACRES640_XYCENTER_X_YCENT      CENTER_X        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_X_YCENT      CENTER_Y        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_CENTX        CENTER_X        ACRES640_XYCENTER                <br />ACRES640_XYCENTER_CENTY        CENTER_Y        ACRES640_XYCENTER                <br />A1409_IX1                      SHAPE           WELLHEADERS_25MAY2004_PRJ        <br />R2065_SDE_ROWID_UK             OBJECTID        WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004KID      KID             WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_LATLONG Y_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_LATLONG X_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_YCOORD  Y_COORD         WELLHEADERS_25MAY2004_PRJ        <br />WELLHEADERS_25_MAY2004_XCOORD  X_COORD         WELLHEADERS_25MAY2004_PRJ        <br /><br />14 rows selected.<br /><br />                                               <br /><br /><br />HERE IS THE QUERY THAT I CAME UP WITH....<br /><br /><br /><br />FIRST I WANT TO SELECT THE SECTION ID, WELL ID, THE DISTANCE FROM THE WELL TO THE <br />CENTER OF THE SECTION, & THE QUADRANT OF THE SECTION (NW,NE,SW,SE) THAT THE WELL<br />IS IN ALL WITHIN A 7200 X 7200 METER BOUDING BOX (CENTERED ON THE SECTION CENTER) <br />FOR EVERY SECTION IN MY STUDY AREA.  <br /><br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /><br /><br /><br /><br />   RECNMBR        KID QU DISTANCE_TO_CELL<br />---------- ---------- -- ----------------<br />     49950 1006068633 SW       4129.70144<br />     49950 1006068137 SW       3580.94959<br />     49950 1002919963 SW       4519.08055<br />     49950 1006068032 SE       3446.22605<br />     49950 1006068206 SW       2316.18501<br />     49950 1022362561 SW       3422.35124<br />     49950 1006068139 SW       1594.49365<br />     49950 1001235397 SW       3128.24951<br />     49950 1022009618 SW       2460.49934<br />     49950 1006068479 SW       1646.93169<br />     49950 1006068208 SW       2039.86985<br />     49950 1026642145 NW       2022.24281<br />     49950 1025778509 NW       2062.54042<br />     49950 1025686933 NW       3158.56803<br />     49950 1022362563 NW       3747.38909<br />     49950 1006068200 NW       3791.15352<br />     49950 1022009617 NW       2596.05951<br />     49950 1020066904 NW       3337.37142<br />     49950 1006068395 NW       4568.36393<br />     49952 1006068633 SW       3628.02563<br />     49952 1006068437 SW        4142.8273<br />     49952 1006068137 SW       3201.38033<br />     49952 1002919963 SW        3479.8352<br />     49952 1008378808 SW       4545.26149<br />     49952 1002920004 SW       4531.73697<br />     49952 1008764319 SW       3459.29299<br />     49952 1006068206 SE       2021.65502<br />     49952 1022362561 SW         2330.793<br />     49952 1006067823 SW       2810.31617<br />     49952 1002919902 SW       3859.54661<br />     49952 1006068139 SE       2240.00223<br />     49952 1001235397 SW       1855.94854<br />     49952 1022009618 SW       1463.18591<br />     49952 1006068585 SW       2491.16539<br />     49952 1006068479 SE       1237.73503<br />     49952 1006068381 SW       3055.63512<br />     49952 1027708907 SW       3536.07494<br />     49952 1006067716 SW       2673.85303<br />     49952 1006068208 SW       558.660004<br />     49952 1006067854 SW       2193.10054<br />     49952 1026642145 NW       435.910541<br />     49952 1025778509 NW       603.927976<br />     49952 1002919979 NW       2058.37266<br />     49952 1025686933 NW       1719.64764<br />     49952 1022362563 NW       2248.00022<br />     49952 1006068200 NW       2332.77196<br />     49952 1006068683 NW       3040.36527<br />     49952 1006067983 NW       3812.09299<br />     49952 1022009617 NW       1515.13201<br />     49952 1020066904 NW       2175.32802<br /><br />THEN I USE THE ANALYTICAL FUNCTION DENSE_RANK TO ASSIGN A RANKING VALUE FOR <br />THE DISTANCE BY SECTION NUMBER (RECNMBR) TO EACH WELL<br /><br />select recnmbr, kid, quadrant, distance_to_cell,         <br /> dense_rank()<br />       over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />from (       <br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /> )<br />   <br />   <br /><br /><br />   RECNMBR        KID QU DISTANCE_TO_CELL TOPN_TOTAL<br />---------- ---------- -- ---------------- ----------   <br />     49948 1006068139 SW       2280.82989          1<br />     49948 1006068032 SE       2320.57859          2<br />     49948 1006068479 SW        3008.3173          3<br />     49948 1006068206 SW       3434.70581          4<br />     49948 1006068198 SE       3514.10543          5<br />     49948 1006067819 NE       4519.37982          6<br />     49948 1006068137 SW       4533.81749          7<br />     49948 1006068188 SE       4542.85417          8<br />     49950 1006068139 SW       1594.49365          1<br />     49950 1006068479 SW       1646.93169          2<br />     49950 1026642145 NW       2022.24281          3<br />     49950 1006068208 SW       2039.86985          4<br />     49950 1025778509 NW       2062.54042          5<br />     49950 1006068206 SW       2316.18501          6<br />     49950 1022009618 SW       2460.49934          7<br />     49950 1022009617 NW       2596.05951          8<br />     49950 1001235397 SW       3128.24951          9<br />     49950 1025686933 NW       3158.56803         10<br />     49950 1020066904 NW       3337.37142         11<br />     49950 1022362561 SW       3422.35124         12<br />     49950 1006068032 SE       3446.22605         13<br />     49950 1006068137 SW       3580.94959         14<br />     49950 1022362563 NW       3747.38909         15<br />     49950 1006068200 NW       3791.15352         16<br />     49950 1006068633 SW       4129.70144         17<br />     49950 1002919963 SW       4519.08055         18<br />     49950 1006068395 NW       4568.36393         19<br />     49952 1026642145 NW       435.910541          1<br />     49952 1006068208 SW       558.660004          2<br />     49952 1025778509 NW       603.927976          3<br />     49952 1006068479 SE       1237.73503          4<br />     49952 1022009618 SW       1463.18591          5<br />     49952 1022009617 NW       1515.13201          6<br />     49952 1025686933 NW       1719.64764          7<br />     49952 1001235397 SW       1855.94854          8<br />     49952 1006068206 SE       2021.65502          9<br />     49952 1002919979 NW       2058.37266         10<br />     49952 1020066904 NW       2175.32802         11<br />     49952 1006067854 SW       2193.10054         12<br />     49952 1006068139 SE       2240.00223         13<br />     49952 1022362563 NW       2248.00022         14<br />     49952 1022362561 SW         2330.793         15<br />     49952 1006068200 NW       2332.77196         16<br />     49952 1006068585 SW       2491.16539         17<br />     49952 1006067716 SW       2673.85303         18<br />     49952 1006067823 SW       2810.31617         19<br />     49952 1006068683 NW       3040.36527         20<br />     49952 1006068381 SW       3055.63512         21<br />     49952 1006068137 SW       3201.38033         22<br />     49952 1006068395 NW       3454.67292         23<br />     49952 1008764319 SW       3459.29299         24<br />     49952 1002919963 SW        3479.8352         25<br />     49952 1027708907 SW       3536.07494         26<br />     49952 1006068633 SW       3628.02563         27<br />     49952 1006067983 NW       3812.09299         28<br />     49952 1002919902 SW       3859.54661         29<br />     49952 1013358575 NW       3955.73204         30<br />     49952 1006068437 SW        4142.8273         31<br />     49952 1002920004 SW       4531.73697         32<br />     49952 1008378808 SW       4545.26149         33   <br />     <br />     <br />NEXT WE SELECT THE 8 CLOSEST WELLS FOR EACH SECTION, WE ALSO NEED TO COMPUTE<br />THE COUNT OF THE DISTINCT QUADRANTS.  WE NEED THIS BECAUSE SOME INTERPOLATION <br />TECHNIQUES WORK BETTER IF YOU FORCE THE INTERPOLATED VALUE TO HAVE AT LEAST X <br />NUMBER OF POINTS IN EACH QUADRANT.  IN THIS CASE WE ARE GOING TO WANT TO HAVE <br />AT LEAST ONE WELL IN EACH QUADRANT.<br /><br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL, <br />count(distinct QUADRANT) over (partition by recnmbr) QUAD_COUNT<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />select recnmbr, kid, quadrant, distance_to_cell,<br /> dense_rank()<br />       over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />from (       <br />  select a.recnmbr recnmbr, b.kid kid,<br />    case <br />    when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />    when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />    when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />    when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />     end QUADRANT,<br />  sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />      ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />    from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />   where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />     and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />     and a.center_x >= -320688<br />     and a.center_x <= -284100<br />     and a.center_y >= 169518<br />     and a.center_y <= 242855 <br /> )<br />)<br />where TOPN_TOTAL <= 8<br />)<br />        <br />        <br />   RECNMBR        KID DISTANCE_TO_CELL QU TOPN_TOTAL QUAD_COUNT<br />---------- ---------- ---------------- -- ---------- ----------<br />     49934 1006068645           1800.1 NE          1          3<br />     49934 1006068218       2281.36122 NE          3          3<br />     49934 1006068541       3524.63587 NW          6          3<br />     49934 1006068571        3722.9722 NW          7          3<br />     49934 1006068190       1808.89607 SW          2          3<br />     49934 1006068182       2839.38479 SW          4          3<br />     49934 1006068198       3833.55879 SW          8          3<br />     49934 1006068545       2948.63036 SW          5          3<br />     49935 1006068645       513.778162 NE          1          4<br />     49935 1006079840       4155.58817 NE          7          4<br />     49935 1006068218       1812.26185 NW          2          4<br />     49935 1006068541       4270.07283 NW          8          4<br />     49935 1027709052       3397.06712 SE          3          4<br />     49935 1023930739       3397.06712 SE          3          4<br />     49935 1006068190       3402.91713 SW          4          4<br />     49935 1006068545       3581.14074 SW          5          4<br />     49935 1006068182       4043.25834 SW          6          4<br />     49937 1001243091       2834.38124 NE          1          4<br />     49937 1006344036        3447.8283 NE          6          4<br />     49937 1006068645       3079.22019 NW          3          4<br />     49937 1006079840       3140.74704 NW          4          4<br />     49937 1006068218       3822.73018 NW          8          4<br />     49937 1006078290       3037.51165 SE          2          4<br />     49937 1006078651       3798.06859 SE          7          4<br />     49937 1027709052       3203.50433 SW          5          4<br />     49937 1023930739       3203.50433 SW          5          4<br />     49938 1006079840       3328.76974 NE          4          3<br />     49938 1006344036       4377.68249 NE          7          3<br />     49938 1001243091       3437.66912 NE          5          3<br />     49938 1006068645       1535.64091 NW          1          3<br />     49938 1006068218       2537.84357 NW          2          3<br />     49938 1027709052       2893.72839 SE          3          3<br />     49938 1006078290       3944.43317 SE          6          3<br />     49938 1023930739       2893.72839 SE          3          3        <br /><br /><br />FINALLY WE SELECT ALL SECTIONS THAT HAVE A DISTINCT QUAD COUNT OF 4.  <br />THE 8 CLOSEST WELLS THAT HAVE AT LEAST ONE WELL IN EACH QUADRANT.<br /><br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL, <br />count(distinct QUADRANT) over (partition by recnmbr) QUAD_COUNT<br />from (<br />select recnmbr, kid, distance_to_cell, QUADRANT, TOPN_TOTAL<br />from (<br />  select recnmbr, kid, quadrant, distance_to_cell,<br />  dense_rank()<br />        over (partition by recnmbr order by distance_to_cell  ) TOPN_TOTAL         <br />    from (       <br />   select a.recnmbr recnmbr, b.kid kid,<br />     case <br />     when b.x_coord < a.center_x and b.Y_COORD < a.center_y then 'SW'<br />     when b.x_coord < a.center_x and b.Y_COORD > a.center_y then 'NW'<br />     when b.x_coord > a.center_x and b.Y_COORD < a.center_y then 'SE'<br />     when b.x_coord > a.center_x and b.Y_COORD > a.center_y then 'NE'<br />      end QUADRANT,<br />   sqrt( ( (b.x_coord - a.center_x) * (b.x_coord - a.center_x) ) + <br />       ( (b.Y_COORD - a.center_y) * (b.Y_COORD - a.center_y) ) ) distance_to_cell<br />     from ACRES640_XYCENTER a, WELLHEADERS_25MAY2004_PRJ b<br />    where b.y_coord between a.center_y - 3600 and a.center_y + 3600 <br />      and b.x_coord between a.center_x - 3600  and a.center_x + 3600 <br />      and a.center_x >= -320688<br />      and a.center_x <= -284100<br />      and a.center_y >= 169518<br />      and a.center_y <= 242855 <br />  )<br /> )<br />where TOPN_TOTAL <= 8<br />)<br />)<br />where QUAD_COUNT = 4<br /><br />   RECNMBR        KID DISTANCE_TO_CELL QU TOPN_TOTAL                            <br />---------- ---------- ---------------- -- ----------                            <br />     49935 1006068645       513.778162 NE          1                            <br />     49935 1006079840       4155.58817 NE          7                            <br />     49935 1006068218       1812.26185 NW          2                            <br />     49935 1006068541       4270.07283 NW          8                            <br />     49935 1027709052       3397.06712 SE          3                            <br />     49935 1023930739       3397.06712 SE          3                            <br />     49935 1006068190       3402.91713 SW          4                            <br />     49935 1006068545       3581.14074 SW          5                            <br />     49935 1006068182       4043.25834 SW          6                            <br />     49937 1001243091       2834.38124 NE          1                            <br />     49937 1006344036        3447.8283 NE          6                            <br />     49937 1006068645       3079.22019 NW          3                            <br />     49937 1006079840       3140.74704 NW          4                            <br />     49937 1006068218       3822.73018 NW          8                            <br />     49937 1006078290       3037.51165 SE          2                            <br />     49937 1006078651       3798.06859 SE          7                            <br />     49937 1027709052       3203.50433 SW          5                            <br />     49937 1023930739       3203.50433 SW          5                            <br />     49942 1006068571        3908.5835 NE          7                            <br />     49942 1006067819       3588.20693 NW          6                            <br />     49942 1006068190       1423.03127 SE          1                            <br />     49942 1006068545       3960.37902 SE          8                            <br />     49942 1006068182       2597.02849 SE          3                            <br />     49942 1006068198       1792.30578 SW          2                            <br />     49942 1006068032       2809.95267 SW          4                            <br />     49942 1006068188       3394.99411 SW          5                            <br />     49960 1025686933       1021.17188 NE          3                            <br />     49960 1025778509       1262.06537 NE          8                            <br />     49960 1026642145       1187.63041 NE          6                            <br />     49960 1002919979       575.591869 NW          1                            <br />     49960 1022362563       1078.89063 NW          4                            <br />     49960 1006068208       1259.78292 SE          7                            <br />     49960 1006067854       595.014286 SW          2                            <br />     49960 1006067716       1167.87414 SW          5                            <br />     49965 1006068379       573.098595 NE          3                            <br />     49965 1006067673       1086.42993 NE          6                            <br />     49965 1022362558       591.472738 NW          4                            <br />     49965 1026642147       1239.35548 NW          7                            <br />     49965 1021121940       1074.38029 SE          5                            <br />     49965 1006068265       1253.18953 SE          8                            <br />     49965 1002919999        276.06521 SW          1                            <br />     49965 1025777349       300.026665 SW          2                            <br />     49966 1006068143       574.381406 NE          5                            <br />     49966 1006067881       1014.58563 NE          7                            <br />     49966 1002919986       572.856876 NW          4                            <br />     49966 1002919921       277.200289 SE          1                            <br />     49966 1008378793       280.189222 SE          2                            <br />     49966 1001235373       589.896601 SE          6                            <br />     49966 1006068265       557.917557 SW          3                            <br />     49966 1021121940       1121.31396 SW          8                            <br />     49969 1002919979       1253.72166 NE          8                            <br />     49969 1022362560       608.152941 NW          3                            <br />     49969 1006067716       855.977803 SE          4                            <br />     49969 1006067854       1024.65311 SE          5                            <br />     49969 1008378866        566.39209 SW          1                            <br />     49969 1027708907       1095.42777 SW          6                            <br />     49969 1001235373        1251.9976 SW          7                            <br />     49969 1027625616       591.959458 SW          2                            <br />     49979 1006068577       531.497883 NE          3                            <br />     49979 1006068477        1251.4128 NE          6                            <br />     49979 1006068591       1255.48755 NW          7                            <br />     49979 1013358584        614.18564 SE          4                            <br />     49979 1019411297       1270.18739 SE          8                            <br />     49979 1006812097       280.189222 SW          1                            <br />     49979 1006067545       282.242803 SW          2                            <br />     49979 1006068726       1042.14826 SW          5                            <br />AND ON AND ON....                        <br />     68143 1028445209       1044.73585 NE          2                            <br />     68143 1002950389       1708.98391 NE          5                            <br />     68143 1006155639       2714.99411 NE          8                            <br />     68143 1025830097       1073.93203 NE          3                            <br />     68143 1006154723       574.464968 NW          1                            <br />     68143 1002950475       2615.97898 SE          7                            <br />     68143 1006155021       1442.30718 SW          4                            <br />     68143 1028445211       1994.58467 SW          6                            <br />     68167 1006155879       1637.48099 NE          5                            <br />     68167 1001322873       1704.43246 NE          6                            <br />     68167 1022009791       1951.95722 NW          8                            <br />     68167 1006154897       1160.19007 SE          1                            <br />     68167 1002950448       1427.05431 SE          3                            <br />     68167 1006154895         1501.003 SE          4                            <br />     68167 1006155257       1385.55873 SW          2                            <br />     68167 1025830091       1778.85188 SW          7                            <br />     68184 1006155899       618.684087 NE          2                            <br />     68184 1006155931       1399.38915 NE          3                            <br />     68184 1006154883       1695.66329 NE          8                            <br />     68184 1006154895        1690.6274 NW          6                            <br />     68184 1004752885       1492.82618 SE          4                            <br />     68184 1027709638       1693.48664 SE          7                            <br />     68184 1004752884        13.892444 SW          1                            <br />     68184 1004752837       1620.26448 SW          5                            <br />     68187 1006154875       1567.44537 NE          3                            <br />     68187 1006155899       2200.32952 NE          7                            <br />     68187 1006154895       101.828287 NW          1                            <br />     68187 1006155879       1575.13079 NW          4                            <br />     68187 1001322873       2265.00618 NW          8                            <br />     68187 1006154897       423.398158 NW          2                            <br />     68187 1004752884       1595.49271 SE          5                            <br />     68187 1002950448       1993.30304 SW          6                            <br /><br />4396 rows selected.<br /><br />Elapsed: 00:00:25.04<br /><br />Execution Plan<br />----------------------------------------------------------                      <br />   0      SELECT STATEMENT Optimizer=CHOOSE (Cost=1402 Card=2330 Bytes          <br />          =160770)                                                              <br />                                                                                <br />   1    0   VIEW (Cost=1402 Card=2330 Bytes=160770)                             <br />   2    1     WINDOW (SORT) (Cost=1402 Card=2330 Bytes=130480)                  <br />   3    2       VIEW (Cost=1329 Card=2330 Bytes=130480)                         <br />   4    3         WINDOW (SORT PUSHED RANK) (Cost=1329 Card=2330 Bytes          <br />          =69900)                                                               <br />                                                                                <br />   5    4           TABLE ACCESS (BY INDEX ROWID) OF 'WELLHEADERS_25MA          <br />          Y2004_PRJ' (Cost=2 Card=2 Bytes=32)                                   <br />                                                                                <br />   6    5             NESTED LOOPS (Cost=1264 Card=2330 Bytes=69900)            <br />   7    6               TABLE ACCESS (FULL) OF 'ACRES640_XYCENTER' (Co          <br />          st=72 Card=993 Bytes=13902)                                           <br />                                                                                <br />   8    6               INDEX (RANGE SCAN) OF 'WELLHEADERS_25_MAY2004_          <br />          LATLONG' (NON-UNIQUE) (Cost=6 Card=1690)                              <br />                                                                                <br /><br /><br /><br /><br />Statistics<br />----------------------------------------------------------                      <br />          0  recursive calls                                                    <br />          4  db block gets                                                      <br />      65267  consistent gets                                                    <br />        142  physical reads                                                     <br />          0  redo size                                                          <br />     183474  bytes sent via SQL*Net to client                                   <br />       2326  bytes received via SQL*Net from client                             <br />        295  SQL*Net roundtrips to/from client                                  <br />          0  sorts (memory)                                                     <br />          2  sorts (disk)                                                       <br />       4396  rows processed                                                     <br /><br />SQL> <br /><br /><br />THE NEXT STEP WOULD BE ACTUALLY DO THE INTERPOLATION....AVERAGE SOME VALUE WHERE <br />WELL KID = QUERY FROM ABOVE....</PRE><br /><br />Questions/Comments?  <br /><br />Cheers,<br /><br />Jeremy";}i:4;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-114170714393612375";s:7:"pubdate";s:31:"Tue, 07 Mar 2006 03:49:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-03-06T22:57:14.430-06:00";}s:5:"title";s:18:"Summary Statistics";s:11:"description";s:4470:"One of my most used web pages is a page that summarizes a numeric column for min, max, standard deviation, count, and produces a 10 class equal binned <a href="http://en.wikipedia.org/wiki/Histogram">histogram</a>.   One way to do this within Oracle is to execute two queries.   The first query gives us the minimum and maximum value to establish how big our binned histogram buckets need to be.   The second query counts the number of rows that fall within each bucket.<br /><br />Take the following interactive <a href="http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm">map</a> from the Kansas Well Top Stratigraphy Viewer:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/chase.1.png"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/chase.0.jpg" alt="" border="0" /></a><br /><br />The map above is displaying the depth of the Chase formation wells in Kansas relative to sea level.  The statistical summary of that dataset can be viewed by selecting the "View Current Viewing Stats" link.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/chase_stats.png"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/chase_stats.jpg" alt="" border="0" /></a><br /><br />The first query gives us the min, max, standard deviation, and count.<br /><pre><br />SELECT avg(WELL_TOP_SEALEVEL) average,<br />     min(WELL_TOP_SEALEVEL) minimum,<br />     max(WELL_TOP_SEALEVEL) maximum,<br />     stddev(WELL_TOP_SEALEVEL) standard_dev,<br />     count(WELL_TOP_SEALEVEL) count<br />FROM PLSS.strat_well_top_1MAR2006<br />WHERE FORMATION_NAME = 'Chase Group'<br /> and WELL_TOP is not null<br /> and WELL_TOP <> 9999<br /> and GROUND_ELEVATION > 0<br /> and LONGITUDE >= -102.25798<br /> and LONGITUDE <= -94.201246      and LATITUDE >= 34.4665145<br /> and LATITUDE <= 42.5232570</pre><br /><br />All we are really doing is letting the database summarize (avg, min, max, etc.) a numeric column (WELL_TOP_SEALEVEL) based on the where criteria (the formation is Chase Group, the well value exists, the well ground elevation is above 0, and the well is within the current viewing extent).<br /><br />Once we know the min and max value we can produce a query that counts the number of rows that fall within an equal 10 class range.<br /><br /><pre><br />SELECT avg(WELL_TOP_SEALEVEL) average,<br />      stddev(WELL_TOP_SEALEVEL) stddevvalue, '1' C0<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -643 AND -410.7<br />     then 1<br />     else 0<br />     end) C1<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -410.7 AND -178.4<br />     then 1<br />     else 0<br />     end) C2<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -178.4 AND 53.9<br />     then 1<br />     else 0<br />     end) C3<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 53.9 AND 286.2<br />     then 1<br />     else 0<br />     end) C4<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 286.2 AND 518.5<br />     then 1<br />     else 0<br />     end) C5<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 518.5 AND 750.8<br />     then 1<br />     else 0<br />     end) C6<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 750.8 AND 983.1<br />     then 1<br />     else 0<br />     end) C7<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 983.1 AND 1215.4<br />     then 1<br />     else 0<br />     end) C8<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 1215.4 AND 1447.7<br />     then 1<br />     else 0<br />     end) C9<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 1447.7 AND 1680<br />     then 1<br />     else 0<br />     end) C10<br /> FROM PLSS.strat_well_top_1MAR2006<br />WHERE FORMATION_NAME = 'Chase Group'<br />  AND WELL_TOP is not null<br />  AND WELL_TOP <> 9999<br /></pre><br /><br />Here we are using the case function on a row by row basis. <br /><b><pre><br />sum(case    <br />     when WELL_TOP_SEALEVEL between 1447.7 AND 1680<br />     then 1<br />     else 0<br />   end)<br /></pre></b><br />If the value is between x and y then give it a value of 1, otherwise give it a value of 0.  When we sum up that count for all rows we end up with a number of rows where the value is within the pre-defined bin.<br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:58:"http://geosql.blogspot.com/2006/03/summary-statistics.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"0";}s:7:"summary";s:4470:"One of my most used web pages is a page that summarizes a numeric column for min, max, standard deviation, count, and produces a 10 class equal binned <a href="http://en.wikipedia.org/wiki/Histogram">histogram</a>.   One way to do this within Oracle is to execute two queries.   The first query gives us the minimum and maximum value to establish how big our binned histogram buckets need to be.   The second query counts the number of rows that fall within each bucket.<br /><br />Take the following interactive <a href="http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm">map</a> from the Kansas Well Top Stratigraphy Viewer:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/chase.1.png"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/chase.0.jpg" alt="" border="0" /></a><br /><br />The map above is displaying the depth of the Chase formation wells in Kansas relative to sea level.  The statistical summary of that dataset can be viewed by selecting the "View Current Viewing Stats" link.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/chase_stats.png"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/chase_stats.jpg" alt="" border="0" /></a><br /><br />The first query gives us the min, max, standard deviation, and count.<br /><pre><br />SELECT avg(WELL_TOP_SEALEVEL) average,<br />     min(WELL_TOP_SEALEVEL) minimum,<br />     max(WELL_TOP_SEALEVEL) maximum,<br />     stddev(WELL_TOP_SEALEVEL) standard_dev,<br />     count(WELL_TOP_SEALEVEL) count<br />FROM PLSS.strat_well_top_1MAR2006<br />WHERE FORMATION_NAME = 'Chase Group'<br /> and WELL_TOP is not null<br /> and WELL_TOP <> 9999<br /> and GROUND_ELEVATION > 0<br /> and LONGITUDE >= -102.25798<br /> and LONGITUDE <= -94.201246      and LATITUDE >= 34.4665145<br /> and LATITUDE <= 42.5232570</pre><br /><br />All we are really doing is letting the database summarize (avg, min, max, etc.) a numeric column (WELL_TOP_SEALEVEL) based on the where criteria (the formation is Chase Group, the well value exists, the well ground elevation is above 0, and the well is within the current viewing extent).<br /><br />Once we know the min and max value we can produce a query that counts the number of rows that fall within an equal 10 class range.<br /><br /><pre><br />SELECT avg(WELL_TOP_SEALEVEL) average,<br />      stddev(WELL_TOP_SEALEVEL) stddevvalue, '1' C0<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -643 AND -410.7<br />     then 1<br />     else 0<br />     end) C1<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -410.7 AND -178.4<br />     then 1<br />     else 0<br />     end) C2<br />,sum(case<br />     when WELL_TOP_SEALEVEL between -178.4 AND 53.9<br />     then 1<br />     else 0<br />     end) C3<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 53.9 AND 286.2<br />     then 1<br />     else 0<br />     end) C4<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 286.2 AND 518.5<br />     then 1<br />     else 0<br />     end) C5<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 518.5 AND 750.8<br />     then 1<br />     else 0<br />     end) C6<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 750.8 AND 983.1<br />     then 1<br />     else 0<br />     end) C7<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 983.1 AND 1215.4<br />     then 1<br />     else 0<br />     end) C8<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 1215.4 AND 1447.7<br />     then 1<br />     else 0<br />     end) C9<br />,sum(case<br />     when WELL_TOP_SEALEVEL between 1447.7 AND 1680<br />     then 1<br />     else 0<br />     end) C10<br /> FROM PLSS.strat_well_top_1MAR2006<br />WHERE FORMATION_NAME = 'Chase Group'<br />  AND WELL_TOP is not null<br />  AND WELL_TOP <> 9999<br /></pre><br /><br />Here we are using the case function on a row by row basis. <br /><b><pre><br />sum(case    <br />     when WELL_TOP_SEALEVEL between 1447.7 AND 1680<br />     then 1<br />     else 0<br />   end)<br /></pre></b><br />If the value is between x and y then give it a value of 1, otherwise give it a value of 0.  When we sum up that count for all rows we end up with a number of rows where the value is within the pre-defined bin.<br /><br />Cheers,<br /><br />Jeremy";}i:5;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-113924636673796925";s:7:"pubdate";s:31:"Mon, 06 Feb 2006 16:14:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2006-03-06T21:47:45.166-06:00";}s:5:"title";s:49:"The Power of the Spatial to Attribute Join-Part 3";s:11:"description";s:9517:"Sorry for the long delay between posts!<br /><br />Today we are going to look at multi-dimensional subsurface mapping.  First a little background.  The <a href="http://www.kgs.ku.edu">Kansas Geological Survey</a> has an extensive database of subsurface tops. A geologic top is the depth in feet from the surface to a particular geologic unit (system, group, formation, member). This data is collected from numerous scientists working over many years. When a well is drilled (mostly for petroleum) geophysical logs are run in the hole to measure different properties of the rocks. These electric logs are scanned, studied, and geologic units are picked from the logs (Chase group, Permian system, Fort Scott limestone formation). Read this <a href="http://www.kgs.ku.edu/Publications/Oil/primer07.html">primer</a> for more information.<br /><br />So what does this mean for GIS and SQL? With this database we have access to over 1,700,000 called tops spread across ~150,000 wells in the state of Kansas. Each well can/will have more than one called formation. We have more than one record per geographic location--in this case the records represent mulitple entries (formations) in the z domain.<br /><br />We can visualize some of this dataset in ArcScene (or any other 3D package).<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_top_3d_small.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_top_3d_smaller.PNG" alt="" border="0" /></a><br />Most analysis and visualization occurs when users map one unit of measure (depth to unit, thickness between units, or something else entirely) per geographic location.<br /><br />The query to select an individual unit is pretty easy.<br /><br /><pre>SQL&gt; desc strat_well_top_1JUN2005<br />Name                              Null?    Type<br />--------------------------------- -------- ------------------------<br />FORMATION_NAME                    NOT NULL VARCHAR2(60)<br />WELL_HEADER_KID                   NOT NULL NUMBER(10)<br />WELL_TOP                                   NUMBER(8,2)<br />FIELD_KID                                  NUMBER(10)<br />LATITUDE                                   NUMBER(11,6)<br />LONGITUDE                                  NUMBER(11,6)<br />GROUND_ELEVATION                           VARCHAR2(40)<br />GROUND_ELEVATION_SOURCE                    VARCHAR2(12)<br />WELL_TOP_SEALEVEL_NON_NED                  VARCHAR2(40)<br />WELL_TOP_SEALEVEL                          NUMBER<br /><br />1  select well_header_kid, latitude, longitude,<br />2         well_top, well_top_sealevel<br />3  from strat_well_top_1JUN2005<br />4* where FORMATION_NAME = 'Permian System'<br />SQL&gt; /<br /><br /><br />WELL_HEADER_KID   LATITUDE  LONGITUDE   WELL_TOP WELL_TOP_SEALEVEL<br />--------------- ---------- ---------- ---------- -----------------<br />1025687130   37.58751 -101.36115        680             -2381<br />1028094976   37.61659 -100.73941        834             -2095<br />1006155619   37.39194 -101.67532        608             -2673<br />1006514758   39.99071  -97.14744        358             -1158<br />1025773538   37.20899 -101.90656       1395             -2120<br />1024492073   37.00136 -100.56991       3550              1170<br />1026599879   37.91949 -101.48087        660             -2529<br />1006054521   37.50601  -99.70401        387             -2066<br />1006054213   37.53783   -99.8804        417             -2098<br />1006054635   37.48215 -100.02145        412             -2179<br />1002915548   37.55853 -100.38357        775             -2008<br /><br /></pre><br />This can be done easily outside of database. With ArcMap you can do a definition query to limit the tabluar dataset to only the unit in question. <br /><br>With ArcIMS you can perform an ArcXML spatial query to only select the unit in question.<br /><pre>&lt;LAYER type=&quot;featureclass&quot; name=&quot;Depth&quot; visible=&quot;true&quot;&gt;<br />&lt;DATASET fromlayer=&quot;1&quot; /&gt;<br />&lt;SPATIALQUERY searchorder=&quot;attributefirst&quot;<br />where=&quot;PLSS.WELL_HEADERS_29AUG2003.KID = PLSS.STRAT_WELL_TOP_28AUG2003.WELL_HEADER_KID<br />and PLSS.STRAT_WELL_TOP_28AUG2003.FORMATION_NAME = 'Permian System'<br />and PLSS.STRAT_WELL_TOP_28AUG2003.WELL_TOP &lt;&gt; 9999<br />and PLSS.STRAT_WELL_TOP_28AUG2003.GROUND_ELEVATION &gt; 0&quot;<br />jointables=&quot;PLSS.STRAT_WELL_TOP_28AUG2003&quot; /&gt;<br />&lt;VALUEMAPRENDERER lookupfield=&quot;PLSS.STRAT_WELL_TOP_28AUG2003.WELL_TOP&quot;&gt;<br />&lt;RANGE lower=&quot;15&quot; upper=&quot;326&quot; label=&quot;15 TO 326&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;56,168,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;326&quot; upper=&quot;637&quot; label=&quot;326 TO 637&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;90,186,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;637&quot; upper=&quot;949&quot; label=&quot;637 TO 949&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;131,207,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;949&quot; upper=&quot;1260&quot; label=&quot;949 TO 1260&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;176,224,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1260&quot; upper=&quot;1571&quot; label=&quot;1260 TO 1571&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;228,245,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1571&quot; upper=&quot;1882&quot; label=&quot;1571 TO 1882&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,225,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1882&quot; upper=&quot;2193&quot; label=&quot;1882 TO 2193&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,170,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2193&quot; upper=&quot;2504&quot; label=&quot;2193 TO 2504&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,115,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2504&quot; upper=&quot;2816&quot; label=&quot;2504 TO 2816&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,55,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2816&quot; upper=&quot;3550&quot; label=&quot;2816 TO 3550&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,0,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;/VALUEMAPRENDERER&gt;<br />&lt;/LAYER&gt;<br /></pre><br />This looks like....<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/permian_tops.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/permian_tops.PNG" alt="" border="0" /></a><br /><br />Lets get a little more complicated. Say you want to compute the thickness between two different formations. One way to do this is to select the two formations of interest, group the results, and select the difference between the min depth value and the max depth value.<br /><br /><pre><br />select WELL_HEADER_KID, round(max(WELL_TOP) - min(WELL_TOP),1) STRAT_THICKNESS<br />from strat_well_top_1JUN2005<br />where (formation_name = 'Chase Group'<br />or formation_name = 'Council Grove Group')<br />and WELL_TOP is not null<br />and WELL_TOP &lt;&gt; 9999<br />and LONGITUDE &gt;= -103.57371<br />and LONGITUDE &lt;= -98.352965    <br />and LATITUDE &gt;= 34.9908216<br />and LATITUDE &lt;= 40.2115692 <br />group by WELL_HEADER_KID <br />having count(distinct formation_name) = 2<br />and max(WELL_TOP) - min(WELL_TOP) &gt; 0<br />and max(WELL_TOP) - min(WELL_TOP) &lt;&gt; max(WELL_TOP)<br /></pre><br /><br />By selecting only the Chase Group and the Council Grove Group we lower our tops table to records that have either the Chase or The Council Grove. Once we group by the well_header_kid and select records that have rows in both groups we can do the math to compute the thickness.<br /><pre>group by WELL_HEADER_KID <br /> having count(distinct formation_name) = 2 </pre><br />This drops records of wells that have one group or the other, but not both.<br /><br />Now we can subtract the &quot;min(well_top)&quot; depth from the &quot;max(well_top)&quot; depth to compute the thickness between the two groups for a particluar well.<br /><br />Slap that query to a view and join that in ArcIMS and you have nice point map of the thickness between two geologic groups.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_council_thickness.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_council_thickness.PNG" alt="" border="0" /></a><br /><br />Give it a try at:  <a href="http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm">http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm</a><br /><br />Or we can use ArcGIS server to generate a raster dataset off that that view (example application coming soon).<br /><br />What do you think?<br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:74:"http://geosql.blogspot.com/2006/02/power-of-spatial-to-attribute-join.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"5";}s:7:"summary";s:9517:"Sorry for the long delay between posts!<br /><br />Today we are going to look at multi-dimensional subsurface mapping.  First a little background.  The <a href="http://www.kgs.ku.edu">Kansas Geological Survey</a> has an extensive database of subsurface tops. A geologic top is the depth in feet from the surface to a particular geologic unit (system, group, formation, member). This data is collected from numerous scientists working over many years. When a well is drilled (mostly for petroleum) geophysical logs are run in the hole to measure different properties of the rocks. These electric logs are scanned, studied, and geologic units are picked from the logs (Chase group, Permian system, Fort Scott limestone formation). Read this <a href="http://www.kgs.ku.edu/Publications/Oil/primer07.html">primer</a> for more information.<br /><br />So what does this mean for GIS and SQL? With this database we have access to over 1,700,000 called tops spread across ~150,000 wells in the state of Kansas. Each well can/will have more than one called formation. We have more than one record per geographic location--in this case the records represent mulitple entries (formations) in the z domain.<br /><br />We can visualize some of this dataset in ArcScene (or any other 3D package).<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_top_3d_small.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_top_3d_smaller.PNG" alt="" border="0" /></a><br />Most analysis and visualization occurs when users map one unit of measure (depth to unit, thickness between units, or something else entirely) per geographic location.<br /><br />The query to select an individual unit is pretty easy.<br /><br /><pre>SQL&gt; desc strat_well_top_1JUN2005<br />Name                              Null?    Type<br />--------------------------------- -------- ------------------------<br />FORMATION_NAME                    NOT NULL VARCHAR2(60)<br />WELL_HEADER_KID                   NOT NULL NUMBER(10)<br />WELL_TOP                                   NUMBER(8,2)<br />FIELD_KID                                  NUMBER(10)<br />LATITUDE                                   NUMBER(11,6)<br />LONGITUDE                                  NUMBER(11,6)<br />GROUND_ELEVATION                           VARCHAR2(40)<br />GROUND_ELEVATION_SOURCE                    VARCHAR2(12)<br />WELL_TOP_SEALEVEL_NON_NED                  VARCHAR2(40)<br />WELL_TOP_SEALEVEL                          NUMBER<br /><br />1  select well_header_kid, latitude, longitude,<br />2         well_top, well_top_sealevel<br />3  from strat_well_top_1JUN2005<br />4* where FORMATION_NAME = 'Permian System'<br />SQL&gt; /<br /><br /><br />WELL_HEADER_KID   LATITUDE  LONGITUDE   WELL_TOP WELL_TOP_SEALEVEL<br />--------------- ---------- ---------- ---------- -----------------<br />1025687130   37.58751 -101.36115        680             -2381<br />1028094976   37.61659 -100.73941        834             -2095<br />1006155619   37.39194 -101.67532        608             -2673<br />1006514758   39.99071  -97.14744        358             -1158<br />1025773538   37.20899 -101.90656       1395             -2120<br />1024492073   37.00136 -100.56991       3550              1170<br />1026599879   37.91949 -101.48087        660             -2529<br />1006054521   37.50601  -99.70401        387             -2066<br />1006054213   37.53783   -99.8804        417             -2098<br />1006054635   37.48215 -100.02145        412             -2179<br />1002915548   37.55853 -100.38357        775             -2008<br /><br /></pre><br />This can be done easily outside of database. With ArcMap you can do a definition query to limit the tabluar dataset to only the unit in question. <br /><br>With ArcIMS you can perform an ArcXML spatial query to only select the unit in question.<br /><pre>&lt;LAYER type=&quot;featureclass&quot; name=&quot;Depth&quot; visible=&quot;true&quot;&gt;<br />&lt;DATASET fromlayer=&quot;1&quot; /&gt;<br />&lt;SPATIALQUERY searchorder=&quot;attributefirst&quot;<br />where=&quot;PLSS.WELL_HEADERS_29AUG2003.KID = PLSS.STRAT_WELL_TOP_28AUG2003.WELL_HEADER_KID<br />and PLSS.STRAT_WELL_TOP_28AUG2003.FORMATION_NAME = 'Permian System'<br />and PLSS.STRAT_WELL_TOP_28AUG2003.WELL_TOP &lt;&gt; 9999<br />and PLSS.STRAT_WELL_TOP_28AUG2003.GROUND_ELEVATION &gt; 0&quot;<br />jointables=&quot;PLSS.STRAT_WELL_TOP_28AUG2003&quot; /&gt;<br />&lt;VALUEMAPRENDERER lookupfield=&quot;PLSS.STRAT_WELL_TOP_28AUG2003.WELL_TOP&quot;&gt;<br />&lt;RANGE lower=&quot;15&quot; upper=&quot;326&quot; label=&quot;15 TO 326&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;56,168,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;326&quot; upper=&quot;637&quot; label=&quot;326 TO 637&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;90,186,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;637&quot; upper=&quot;949&quot; label=&quot;637 TO 949&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;131,207,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;949&quot; upper=&quot;1260&quot; label=&quot;949 TO 1260&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;176,224,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1260&quot; upper=&quot;1571&quot; label=&quot;1260 TO 1571&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;228,245,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1571&quot; upper=&quot;1882&quot; label=&quot;1571 TO 1882&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,225,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;1882&quot; upper=&quot;2193&quot; label=&quot;1882 TO 2193&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,170,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2193&quot; upper=&quot;2504&quot; label=&quot;2193 TO 2504&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,115,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2504&quot; upper=&quot;2816&quot; label=&quot;2504 TO 2816&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,55,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;RANGE lower=&quot;2816&quot; upper=&quot;3550&quot; label=&quot;2816 TO 3550&quot;&gt;<br />&lt;SIMPLEMARKERSYMBOL color=&quot;255,0,0&quot; width=&quot;6&quot; /&gt;<br />&lt;/RANGE&gt;<br />&lt;/VALUEMAPRENDERER&gt;<br />&lt;/LAYER&gt;<br /></pre><br />This looks like....<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/permian_tops.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/permian_tops.PNG" alt="" border="0" /></a><br /><br />Lets get a little more complicated. Say you want to compute the thickness between two different formations. One way to do this is to select the two formations of interest, group the results, and select the difference between the min depth value and the max depth value.<br /><br /><pre><br />select WELL_HEADER_KID, round(max(WELL_TOP) - min(WELL_TOP),1) STRAT_THICKNESS<br />from strat_well_top_1JUN2005<br />where (formation_name = 'Chase Group'<br />or formation_name = 'Council Grove Group')<br />and WELL_TOP is not null<br />and WELL_TOP &lt;&gt; 9999<br />and LONGITUDE &gt;= -103.57371<br />and LONGITUDE &lt;= -98.352965    <br />and LATITUDE &gt;= 34.9908216<br />and LATITUDE &lt;= 40.2115692 <br />group by WELL_HEADER_KID <br />having count(distinct formation_name) = 2<br />and max(WELL_TOP) - min(WELL_TOP) &gt; 0<br />and max(WELL_TOP) - min(WELL_TOP) &lt;&gt; max(WELL_TOP)<br /></pre><br /><br />By selecting only the Chase Group and the Council Grove Group we lower our tops table to records that have either the Chase or The Council Grove. Once we group by the well_header_kid and select records that have rows in both groups we can do the math to compute the thickness.<br /><pre>group by WELL_HEADER_KID <br /> having count(distinct formation_name) = 2 </pre><br />This drops records of wells that have one group or the other, but not both.<br /><br />Now we can subtract the &quot;min(well_top)&quot; depth from the &quot;max(well_top)&quot; depth to compute the thickness between the two groups for a particluar well.<br /><br />Slap that query to a view and join that in ArcIMS and you have nice point map of the thickness between two geologic groups.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_council_thickness.PNG"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 500px;" src="http://hercules.kgs.ku.edu/kgs/oilgas/powerpoints/chase_council_thickness.PNG" alt="" border="0" /></a><br /><br />Give it a try at:  <a href="http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm">http://hercules.kgs.ku.edu/kgs/oilgas/strat_welltops/top_viewer.cfm</a><br /><br />Or we can use ArcGIS server to generate a raster dataset off that that view (example application coming soon).<br /><br />What do you think?<br /><br />Cheers,<br /><br />Jeremy";}i:6;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-113168291182752649";s:7:"pubdate";s:31:"Fri, 11 Nov 2005 03:49:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2005-11-10T22:25:00.936-06:00";}s:5:"title";s:49:"The Power of the Spatial to Attribute Join-Part 2";s:11:"description";s:10252:"This is part two on my series on the mapping and analysis of complex multi-dimensional datasets. Today we will look at historical sea surface temperatures (SST). I am by no means an expert on SST models our on the effect of warming sea surface temperatures on oceanic biological habitat. So take this example with a grain of salt...<br /><br />IMPORTANCE: The number of consecutive records above the max baseline can adversely effect the benthic habitat of the oceanic environment. For example, El Nino can cause coral reef bleaching. This bleaching occurs because sea surface temperatures are continuously above the historical upper limit for the species.<br /><br />GOAL: For every unique ID_ONEDG (unique spatial location), select the maximum number of CONSECUTIVE months that are above the long term average maximum yearly value.<br /><br />EXAMPLE DATASET:  HADL_SST<br />TABLE COMMENTS: Sea Surface Temperatures: OI version 2 SST Analysis from NCEP - Reynolds, Smith, and Stokes. One degree resolution. Monthly from 1871 to 1999. Extent: 40N Latitude to 40S Latitude No land. Modeled data.<br /><br /><pre><br />SQL> desc hadl_sst<br />Name                                      Null?    Type<br />----------------------------------------- -------- ------------<br />ID_ONEDG                                  NOT NULL NUMBER(6)<br />DATE_RECORDED                             NOT NULL DATE<br />SST_CENTIGRADE                            NOT NULL NUMBER(6,2)   <br />      <br />Total number of records:  33676740<br /></pre><br /><br />For speed purposes, for this example, we need to compute the max_baseline_value.<br /><pre><br />create table HADL_SST_AVG_YR_MAX_MNTH as (<br />select ID_ONEDG, avg(yearly_max) MAX_BASELINE_VALUE<br />from (select ID_ONEDG, max(SST_CENTIGRADE) yearly_max<br />     from hadl_sst<br />    group by ID_ONEDG, to_char(DATE_RECORDED, 'YYYY')<br />  )<br />group by ID_ONEDG<br />);<br /><br />SQL> desc HADL_SST_AVG_YR_MAX_MNTH<br />Name                                      Null?    Type<br />----------------------------------------- -------- ---------------------<br />ID_ONEDG                                  NOT NULL NUMBER(6)<br />MAX_BASELINE_VALUE                                 NUMBER<br /><br />Total number of records:  21755<br /></pre><br /><br />Spatial attribute table that contains spatial information about the center of the one degree cell (latitude and longitude). This is a table that is registered with ESRI's spatial database engine (SDE). This can be visualized with traditional GIS software.<br /><br /><pre><br />SQL> desc one_degree<br />Name                                      Null?    Type<br />----------------------------------------- -------- --------------------<br />OBJECTID                                  NOT NULL NUMBER(38)<br />LONG_1                                             NUMBER(6,1)<br />LAT_1                                              NUMBER(6,1)<br />ID_ONEDG                                           NUMBER(6)<br />SHAPE                                              NUMBER(38)<br /><br />Total number of records:  64800<br /></pre><br /><br />The objectives of my approach to this query are:<br />-Select all records that have a monthly temperature greater than the baseline over a predefined three year period centered on an elnino year (or la nina).<br />-Group the selected rows for each ID_ONEDG where the previous record is within a month AND has a temperature value greater than the baseline.<br /><br />This is where we take advantage of the LAG/LEAD Analytical function provided by Oracle.<br /><br /><pre><br />select A.ID_ONEDG ID_ONEDG,<br />  a.date_recorded date_recorded,<br />  case<br />  when date_recorded -<br />       lag(a.date_recorded)<br />          over (order by a.ID_ONEDG,  a.date_recorded)<br />       not between 0 and 35<br />  then rownum<br />end rn,<br />  a.sst_centigrade sst_centigrade,<br />  b.MAX_BASELINE_VALUE MAX_BASELINE_VALUE<br />from hadl_sst a, HADL_SST_AVG_YR_MAX_MNTH B, ONE_DEGREE C<br />where C.LAT_1 between -40 and 40<br />and B.ID_ONEDG = C.ID_ONEDG<br />and A.ID_ONEDG = B.ID_ONEDG<br />and A.date_recorded between<br />  to_date('01-jan-1957', 'dd-mon-yyyy')<br />  and to_date('31-dec-1959', 'dd-mon-yyyy')<br />and a.sst_centigrade > b.MAX_BASELINE_VALUE<br />order by a.ID_ONEDG,  a.date_recorded<br /><br /><br />ID_ONEDG DATE_RECO         RN SST_CENTIGRADE MAX_BASELINE_VALUE<br />---------- --------- ---------- -------------- ------------------<br /> 18041 01-AUG-98         35          20.47         20.1232558<br /> 18042 01-AUG-98                     20.66         19.9818605<br /> 18043 01-AUG-98                      20.7         19.8624806<br /> 18044 01-AUG-98                     20.56         19.6863566<br /> 18044 01-SEP-98                     19.87         19.6863566<br /> 18045 01-AUG-97         40          19.63          19.465969<br /> 18045 01-SEP-97                     19.58          19.465969<br /> 18045 01-AUG-98         42          20.26          19.465969<br /> 18045 01-SEP-98                     19.91          19.465969<br /> 18046 01-AUG-97         44          19.72         19.2837209<br /> 18046 01-SEP-97                     19.65         19.2837209<br /> 18046 01-AUG-98         46          20.05         19.2837209<br /> 18046 01-SEP-98                     19.87         19.2837209<br /></pre><br /><br />Notice that ID_ONEDG of 18045 has two groups of consecutive months where the temperature is greater than the baseline value (Aug-97 to Sep-97 & Aug-98 to Sep-98).<br /><br /><br />-Once the groups have been recognized we need to carry the group id forward.<br /><pre><br />select ID_ONEDG,<br />  nvl(max(rn)<br />      over (order by ID_ONEDG,date_recorded),<br />   -1) max_rn<br />from ( QUERY-FROM-ABOVE )<br />order by 1<br /><br /><br />ID_ONEDG     MAX_RN<br />---------- ----------<br />18041         35<br />18042         35<br />18043         35<br />18044         35<br />18044         35<br />18045         40<br />18045         40<br />18045         42<br />18045         42<br />18046         44<br />18046         44<br />18046         46<br />18046         46<br /></pre><br /><br />Notice that for ID_ONEDG of 18045 we have two groups each with two values (40 and 42).<br /><br />-Now we group id_onedg and the max_rn to compute the count of records that have similar values for id_onedg and max_rn.<br /><br /><pre><br />select ID_ONEDG, count(max_rn) consec_months<br />from ( QUERY-FROM-ABOVE )<br />group by ID_ONEDG, max_rn<br /><br />ID_ONEDG CONSEC_MONTHS<br />---------- -------------<br />18041             1<br />18042             1<br />18043             1<br />18044             2<br />18045             2<br />18045             2<br />18046             2<br />18046             2<br /></pre><br /><br /><br />-Now that we have the count for all consecutive months above the baseline for each id_onedg we need to select the maximum number of consecutive months.<br /><br /><pre><br />select max(consec_months) max_consecutive, ID_ONEDG<br />from ( QUERY-FROM-ABOVE )<br />group by ID_ONEDG<br /><br />MAX_CONSECUTIVE   ID_ONEDG<br />--------------- ----------<br />         1      18041<br />         1      18042<br />         1      18043<br />         2      18044<br />         2      18045<br />         2      18046<br /></pre><br /><br /><br />WRAP-UP: Analytical functions can be very powerful. The only way to do the previous query without analytical functions would be to build a PL/SQL procedure (email me if you want to see that version) that does the max consecutive computation for each spatial location.<br /><br /><pre><br />select max(consec_months) max_consecutive, ID_ONEDG<br /> from<br />    (<br />     select ID_ONEDG, count(max_rn) consec_months<br />       from<br />          (<br />           select ID_ONEDG, nvl(max(rn)<br />                            over(order by ID_ONEDG,date_recorded), -1) max_rn<br />             from<br />                (<br /> select A.ID_ONEDG ID_ONEDG,<br />        a.date_recorded date_recorded,<br />        case<br />               when date_recorded - lag(a.date_recorded) over (order by a.ID_ONEDG,  a.date_recorded) not between 0 and 35<br />        then rownum<br />         end rn,<br />        a.sst_centigrade sst_centigrade,<br />        b.MAX_BASELINE_VALUE MAX_BASELINE_VALUE<br />   from hadl_sst a, HADL_SST_AVG_YR_MAX_MNTH B, ONE_DEGREE C<br />  where C.LAT_1 between -40 and 40<br />    and B.ID_ONEDG = C.ID_ONEDG<br />    and A.ID_ONEDG = B.ID_ONEDG<br />    and A.date_recorded between to_date('01-jan-1997', 'dd-mon-yyyy') and to_date('31-dec-1999', 'dd-mon-yyyy')<br />    and a.sst_centigrade > b.MAX_BASELINE_VALUE<br />  order by a.ID_ONEDG,  a.date_recorded<br />                )<br />            order by 1   <br />          )<br />       group by ID_ONEDG, max_rn<br />    )<br />group by ID_ONEDG<br /><br />21516 rows selected.<br /><br />Elapsed: 00:00:24.06<br /><br /></pre>So what does it look like?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/analysis80_83.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/analysis80_83.png" alt="" border="0" /></a>Conesecutive months above the baseline maximum sea surface temperature for the three year period of 1979 to 1981 (1980 was considered a normal year) and the three year period of 1982 to 1984 (1984 was considered a El Nino period).<br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/analysis89_97.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/analysis89_97.png" alt="" border="0" /></a>Conesecutive months above the baseline maximum sea surface temperature for the three year period of 1988 to 1990 (1989 was considered a La Nina year) and the three year period of 1996 to 1998 (1997 was considered a strong El Nino period).<br /><br />Questions?  Comments?<br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:77:"http://geosql.blogspot.com/2005/11/power-of-spatial-to-attribute-join_10.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"3";}s:7:"summary";s:10252:"This is part two on my series on the mapping and analysis of complex multi-dimensional datasets. Today we will look at historical sea surface temperatures (SST). I am by no means an expert on SST models our on the effect of warming sea surface temperatures on oceanic biological habitat. So take this example with a grain of salt...<br /><br />IMPORTANCE: The number of consecutive records above the max baseline can adversely effect the benthic habitat of the oceanic environment. For example, El Nino can cause coral reef bleaching. This bleaching occurs because sea surface temperatures are continuously above the historical upper limit for the species.<br /><br />GOAL: For every unique ID_ONEDG (unique spatial location), select the maximum number of CONSECUTIVE months that are above the long term average maximum yearly value.<br /><br />EXAMPLE DATASET:  HADL_SST<br />TABLE COMMENTS: Sea Surface Temperatures: OI version 2 SST Analysis from NCEP - Reynolds, Smith, and Stokes. One degree resolution. Monthly from 1871 to 1999. Extent: 40N Latitude to 40S Latitude No land. Modeled data.<br /><br /><pre><br />SQL> desc hadl_sst<br />Name                                      Null?    Type<br />----------------------------------------- -------- ------------<br />ID_ONEDG                                  NOT NULL NUMBER(6)<br />DATE_RECORDED                             NOT NULL DATE<br />SST_CENTIGRADE                            NOT NULL NUMBER(6,2)   <br />      <br />Total number of records:  33676740<br /></pre><br /><br />For speed purposes, for this example, we need to compute the max_baseline_value.<br /><pre><br />create table HADL_SST_AVG_YR_MAX_MNTH as (<br />select ID_ONEDG, avg(yearly_max) MAX_BASELINE_VALUE<br />from (select ID_ONEDG, max(SST_CENTIGRADE) yearly_max<br />     from hadl_sst<br />    group by ID_ONEDG, to_char(DATE_RECORDED, 'YYYY')<br />  )<br />group by ID_ONEDG<br />);<br /><br />SQL> desc HADL_SST_AVG_YR_MAX_MNTH<br />Name                                      Null?    Type<br />----------------------------------------- -------- ---------------------<br />ID_ONEDG                                  NOT NULL NUMBER(6)<br />MAX_BASELINE_VALUE                                 NUMBER<br /><br />Total number of records:  21755<br /></pre><br /><br />Spatial attribute table that contains spatial information about the center of the one degree cell (latitude and longitude). This is a table that is registered with ESRI's spatial database engine (SDE). This can be visualized with traditional GIS software.<br /><br /><pre><br />SQL> desc one_degree<br />Name                                      Null?    Type<br />----------------------------------------- -------- --------------------<br />OBJECTID                                  NOT NULL NUMBER(38)<br />LONG_1                                             NUMBER(6,1)<br />LAT_1                                              NUMBER(6,1)<br />ID_ONEDG                                           NUMBER(6)<br />SHAPE                                              NUMBER(38)<br /><br />Total number of records:  64800<br /></pre><br /><br />The objectives of my approach to this query are:<br />-Select all records that have a monthly temperature greater than the baseline over a predefined three year period centered on an elnino year (or la nina).<br />-Group the selected rows for each ID_ONEDG where the previous record is within a month AND has a temperature value greater than the baseline.<br /><br />This is where we take advantage of the LAG/LEAD Analytical function provided by Oracle.<br /><br /><pre><br />select A.ID_ONEDG ID_ONEDG,<br />  a.date_recorded date_recorded,<br />  case<br />  when date_recorded -<br />       lag(a.date_recorded)<br />          over (order by a.ID_ONEDG,  a.date_recorded)<br />       not between 0 and 35<br />  then rownum<br />end rn,<br />  a.sst_centigrade sst_centigrade,<br />  b.MAX_BASELINE_VALUE MAX_BASELINE_VALUE<br />from hadl_sst a, HADL_SST_AVG_YR_MAX_MNTH B, ONE_DEGREE C<br />where C.LAT_1 between -40 and 40<br />and B.ID_ONEDG = C.ID_ONEDG<br />and A.ID_ONEDG = B.ID_ONEDG<br />and A.date_recorded between<br />  to_date('01-jan-1957', 'dd-mon-yyyy')<br />  and to_date('31-dec-1959', 'dd-mon-yyyy')<br />and a.sst_centigrade > b.MAX_BASELINE_VALUE<br />order by a.ID_ONEDG,  a.date_recorded<br /><br /><br />ID_ONEDG DATE_RECO         RN SST_CENTIGRADE MAX_BASELINE_VALUE<br />---------- --------- ---------- -------------- ------------------<br /> 18041 01-AUG-98         35          20.47         20.1232558<br /> 18042 01-AUG-98                     20.66         19.9818605<br /> 18043 01-AUG-98                      20.7         19.8624806<br /> 18044 01-AUG-98                     20.56         19.6863566<br /> 18044 01-SEP-98                     19.87         19.6863566<br /> 18045 01-AUG-97         40          19.63          19.465969<br /> 18045 01-SEP-97                     19.58          19.465969<br /> 18045 01-AUG-98         42          20.26          19.465969<br /> 18045 01-SEP-98                     19.91          19.465969<br /> 18046 01-AUG-97         44          19.72         19.2837209<br /> 18046 01-SEP-97                     19.65         19.2837209<br /> 18046 01-AUG-98         46          20.05         19.2837209<br /> 18046 01-SEP-98                     19.87         19.2837209<br /></pre><br /><br />Notice that ID_ONEDG of 18045 has two groups of consecutive months where the temperature is greater than the baseline value (Aug-97 to Sep-97 & Aug-98 to Sep-98).<br /><br /><br />-Once the groups have been recognized we need to carry the group id forward.<br /><pre><br />select ID_ONEDG,<br />  nvl(max(rn)<br />      over (order by ID_ONEDG,date_recorded),<br />   -1) max_rn<br />from ( QUERY-FROM-ABOVE )<br />order by 1<br /><br /><br />ID_ONEDG     MAX_RN<br />---------- ----------<br />18041         35<br />18042         35<br />18043         35<br />18044         35<br />18044         35<br />18045         40<br />18045         40<br />18045         42<br />18045         42<br />18046         44<br />18046         44<br />18046         46<br />18046         46<br /></pre><br /><br />Notice that for ID_ONEDG of 18045 we have two groups each with two values (40 and 42).<br /><br />-Now we group id_onedg and the max_rn to compute the count of records that have similar values for id_onedg and max_rn.<br /><br /><pre><br />select ID_ONEDG, count(max_rn) consec_months<br />from ( QUERY-FROM-ABOVE )<br />group by ID_ONEDG, max_rn<br /><br />ID_ONEDG CONSEC_MONTHS<br />---------- -------------<br />18041             1<br />18042             1<br />18043             1<br />18044             2<br />18045             2<br />18045             2<br />18046             2<br />18046             2<br /></pre><br /><br /><br />-Now that we have the count for all consecutive months above the baseline for each id_onedg we need to select the maximum number of consecutive months.<br /><br /><pre><br />select max(consec_months) max_consecutive, ID_ONEDG<br />from ( QUERY-FROM-ABOVE )<br />group by ID_ONEDG<br /><br />MAX_CONSECUTIVE   ID_ONEDG<br />--------------- ----------<br />         1      18041<br />         1      18042<br />         1      18043<br />         2      18044<br />         2      18045<br />         2      18046<br /></pre><br /><br /><br />WRAP-UP: Analytical functions can be very powerful. The only way to do the previous query without analytical functions would be to build a PL/SQL procedure (email me if you want to see that version) that does the max consecutive computation for each spatial location.<br /><br /><pre><br />select max(consec_months) max_consecutive, ID_ONEDG<br /> from<br />    (<br />     select ID_ONEDG, count(max_rn) consec_months<br />       from<br />          (<br />           select ID_ONEDG, nvl(max(rn)<br />                            over(order by ID_ONEDG,date_recorded), -1) max_rn<br />             from<br />                (<br /> select A.ID_ONEDG ID_ONEDG,<br />        a.date_recorded date_recorded,<br />        case<br />               when date_recorded - lag(a.date_recorded) over (order by a.ID_ONEDG,  a.date_recorded) not between 0 and 35<br />        then rownum<br />         end rn,<br />        a.sst_centigrade sst_centigrade,<br />        b.MAX_BASELINE_VALUE MAX_BASELINE_VALUE<br />   from hadl_sst a, HADL_SST_AVG_YR_MAX_MNTH B, ONE_DEGREE C<br />  where C.LAT_1 between -40 and 40<br />    and B.ID_ONEDG = C.ID_ONEDG<br />    and A.ID_ONEDG = B.ID_ONEDG<br />    and A.date_recorded between to_date('01-jan-1997', 'dd-mon-yyyy') and to_date('31-dec-1999', 'dd-mon-yyyy')<br />    and a.sst_centigrade > b.MAX_BASELINE_VALUE<br />  order by a.ID_ONEDG,  a.date_recorded<br />                )<br />            order by 1   <br />          )<br />       group by ID_ONEDG, max_rn<br />    )<br />group by ID_ONEDG<br /><br />21516 rows selected.<br /><br />Elapsed: 00:00:24.06<br /><br /></pre>So what does it look like?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/analysis80_83.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/analysis80_83.png" alt="" border="0" /></a>Conesecutive months above the baseline maximum sea surface temperature for the three year period of 1979 to 1981 (1980 was considered a normal year) and the three year period of 1982 to 1984 (1984 was considered a El Nino period).<br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/analysis89_97.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/analysis89_97.png" alt="" border="0" /></a>Conesecutive months above the baseline maximum sea surface temperature for the three year period of 1988 to 1990 (1989 was considered a La Nina year) and the three year period of 1996 to 1998 (1997 was considered a strong El Nino period).<br /><br />Questions?  Comments?<br /><br />Cheers,<br /><br />Jeremy";}i:7;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-113021112721196985";s:7:"pubdate";s:31:"Tue, 01 Nov 2005 16:00:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2005-11-02T08:22:49.550-06:00";}s:5:"title";s:49:"The Power of the Spatial to Attribute Join-Part 1";s:11:"description";s:7708:"This is the start of a series of posts related to the mapping and analysis of complex multi-dimensional datasets. Traditionally it has been difficult to map multiple dimensional datasets in a GIS. In this series we are going to look at several database driven GIS projects related to multi-dimensional mapping.<br /><br />The first project relates to the mapping and analysis of Kansas Oil and Gas production data.<br /><br /><a href="http://hercules.kgs.ku.edu/kgs/oilgas/production/imageviewertest.cfm">Oil and Gas Production Through Time</a><br /><span style="font-style: italic;"> A dynamic web page that allows a user to map production data by section through time. For each product (oil or gas), you can map production by year, range of years (average or cumulative), or the percent change from one year to another. This is a good example of time-series gis within an enterprise database system.<br /></span>From...  <a href="http://www.kgs.ku.edu/PRS/petroMaps.html">KGS Energy Resources Interactive Maps</a><br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/leases_production_diagram1.jpg"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/leases_production_diagram1.jpg" alt="" border="0"></a>The image to the right contains a table schematic of the main lease table in our database. This table identifies how much oil and gas was produced from a designated lease. As you can see we have:<br /><ul>   <li>time--year and month columns</li>   <li>product--oil or gas<br /></li>   <li>production--amount produced during a particular time, at a particular area, for a particular product  </li>   <li>lease lactation reference--location or locations of the wells or leases</li> </ul> While this is useful information we need to structure it a bit more to make useful real-time mapping visualization. Because of the complex nature of lease information, we cannot currently match leases to particular wells in Kansas. We can aggregate the spatial location of leases up to public land survey boundaries (PLSS). Once we do this aggregation we have a much cleaner table to work with.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/acres_640_diagram.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/acres_640_diagram.jpg" alt="" border="0"></a><br />Where &quot;RECNMBR&quot; is the unique id for a particular 640-acre section in Kansas.<br /><br />From this table can construct queries that identify the amount of production for a particular product for a particular year or for the sum over a range of years.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/oil-gas-view-1990-20001.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/oil-gas-view-1990-20001.jpg" alt="" border="0"></a><br />In the query above we are asking the database to create a view that gives us the sum of gas production between from 1990 to 2000. Within this view we are using the Group By function to group the recnmbr column into a distinct number. Each distinct recnmbr will have multiple production values. First we eliminate all the rows that do not produce gas (where product = 'G') and then we eliminate all the rows where the year is not between 1990 and 2000. We are then left with rows that have produced gas between 1990 and 2000. Take RECNMBR 2555, it has produced gas 10 out of the 12 possible years in that range. We need to summarize these 10 values for this unique RECNMBR. We can perform functions like: count, average, min, max, and sum. In our case we are going to sum the values that fit our criteria.<br /><br />Now we have reduced that multi-dimensional table to one value per spatial polygon (RECNMBR). We can now join that view to a spatial dataset in either ArcMap or ArcIMS. Now we can easily produce a map like this...<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/production_gas_1990-2000.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/production_gas_1990-2000.jpg" alt="" border="0"></a><br /><br />Let's take it a step further and say we want to produce a map of the percent change in gas production between the years 1990 and 2000. To do that we need to formulate a bit more complicated query.<br /><br /><pre>CREATE OR REPLACE VIEW OIL_GAS_WEB_PROD163922 AS<br />(select a.recnmbr as RECNMBR,<br />    decode(sign(avg(b.x1)-avg(c.x2)),<br />           1, ROUND((-100 * (avg(b.x1) - avg(c.x2))/avg(b.x1)),0),<br />           -1,ROUND((-100 * (avg(b.x1) - avg(c.x2))/avg(b.x1)),0),<br />           0) as PERCENTCHANGE<br />from ACRES_640_PRODUCTION a,<br />    (select recnmbr, PRODUCTION x1<br />       from ACRES_640_PRODUCTION<br />      where year = 1990<br />        and product = 'G') b,<br />    (select recnmbr, PRODUCTION x2<br />       from ACRES_640_PRODUCTION<br />      where year = 2000<br />        and product = 'G') c<br />where a.recnmbr = b.recnmbr<br />and a.recnmbr = c.recnmbr<br />and a.year in (1990,2000)<br />and a.product = 'G'<br />group by a.recnmbr<br />union<br />select distinct b.recnmbr RECNMBR,<br />   19901 as PERCENTCHANGE<br />from (select recnmbr,<br />           PRODUCTION x1<br />      from ACRES_640_PRODUCTION<br />     where year = 1990<br />       and product = 'G') b<br />left outer join<br />   (select recnmbr, PRODUCTION x2<br />      from ACRES_640_PRODUCTION<br />     where year = 2000<br />       and product = 'G') c<br />on b.recnmbr = c.recnmbr<br />where b.x1 is not null<br />and c.x2 is null<br />union<br />select distinct c.recnmbr RECNMBR,<br />   20001 as PERCENTCHANGE<br />from (select recnmbr,<br />           PRODUCTION x1<br />      from ACRES_640_PRODUCTION<br />     where year = 1990<br />       and product = 'G') b<br />right outer join<br />   (select recnmbr,<br />           PRODUCTION x2<br />      from ACRES_640_PRODUCTION<br />     where year = 2000<br />       and product = 'G') c<br />on c.recnmbr = b.recnmbr<br />where c.x2 is not null<br />and b.x1 is null )</pre><br />Don't be frightened! The query should be broken up into three parts. The first part will compute the percent change between year 1990 and year 2000 for all the sections where we have gas production in 1990 and in 2000 (<b>and a.year in (1990,2000)</b>). Parts 2 and 3 of the union are specifically for sections that produce in one year, but not the other. The final map looks like...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/oil_gas_vc1990_2000_1.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/oil_gas_vc1990_2000_1.jpg" alt="" border="0"></a><br />Areas in red are places where gas production increased from 1990 to 2000. Areas in blue show a precent decreases. Areas in green did not produce in 1990. Areas in orange stopped producing by 2000. Email <a href="mailto:jbartley@kgs.ku.edu">me</a> if you have any questions.<br /><br />Next time we will look at sea-surface temeratures through time.   I know you can't wait!";s:4:"link";s:74:"http://geosql.blogspot.com/2005/11/power-of-spatial-to-attribute-join.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"0";}s:7:"summary";s:7708:"This is the start of a series of posts related to the mapping and analysis of complex multi-dimensional datasets. Traditionally it has been difficult to map multiple dimensional datasets in a GIS. In this series we are going to look at several database driven GIS projects related to multi-dimensional mapping.<br /><br />The first project relates to the mapping and analysis of Kansas Oil and Gas production data.<br /><br /><a href="http://hercules.kgs.ku.edu/kgs/oilgas/production/imageviewertest.cfm">Oil and Gas Production Through Time</a><br /><span style="font-style: italic;"> A dynamic web page that allows a user to map production data by section through time. For each product (oil or gas), you can map production by year, range of years (average or cumulative), or the percent change from one year to another. This is a good example of time-series gis within an enterprise database system.<br /></span>From...  <a href="http://www.kgs.ku.edu/PRS/petroMaps.html">KGS Energy Resources Interactive Maps</a><br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/leases_production_diagram1.jpg"><img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/leases_production_diagram1.jpg" alt="" border="0"></a>The image to the right contains a table schematic of the main lease table in our database. This table identifies how much oil and gas was produced from a designated lease. As you can see we have:<br /><ul>   <li>time--year and month columns</li>   <li>product--oil or gas<br /></li>   <li>production--amount produced during a particular time, at a particular area, for a particular product  </li>   <li>lease lactation reference--location or locations of the wells or leases</li> </ul> While this is useful information we need to structure it a bit more to make useful real-time mapping visualization. Because of the complex nature of lease information, we cannot currently match leases to particular wells in Kansas. We can aggregate the spatial location of leases up to public land survey boundaries (PLSS). Once we do this aggregation we have a much cleaner table to work with.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/acres_640_diagram.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/acres_640_diagram.jpg" alt="" border="0"></a><br />Where &quot;RECNMBR&quot; is the unique id for a particular 640-acre section in Kansas.<br /><br />From this table can construct queries that identify the amount of production for a particular product for a particular year or for the sum over a range of years.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/oil-gas-view-1990-20001.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/oil-gas-view-1990-20001.jpg" alt="" border="0"></a><br />In the query above we are asking the database to create a view that gives us the sum of gas production between from 1990 to 2000. Within this view we are using the Group By function to group the recnmbr column into a distinct number. Each distinct recnmbr will have multiple production values. First we eliminate all the rows that do not produce gas (where product = 'G') and then we eliminate all the rows where the year is not between 1990 and 2000. We are then left with rows that have produced gas between 1990 and 2000. Take RECNMBR 2555, it has produced gas 10 out of the 12 possible years in that range. We need to summarize these 10 values for this unique RECNMBR. We can perform functions like: count, average, min, max, and sum. In our case we are going to sum the values that fit our criteria.<br /><br />Now we have reduced that multi-dimensional table to one value per spatial polygon (RECNMBR). We can now join that view to a spatial dataset in either ArcMap or ArcIMS. Now we can easily produce a map like this...<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/production_gas_1990-2000.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/production_gas_1990-2000.jpg" alt="" border="0"></a><br /><br />Let's take it a step further and say we want to produce a map of the percent change in gas production between the years 1990 and 2000. To do that we need to formulate a bit more complicated query.<br /><br /><pre>CREATE OR REPLACE VIEW OIL_GAS_WEB_PROD163922 AS<br />(select a.recnmbr as RECNMBR,<br />    decode(sign(avg(b.x1)-avg(c.x2)),<br />           1, ROUND((-100 * (avg(b.x1) - avg(c.x2))/avg(b.x1)),0),<br />           -1,ROUND((-100 * (avg(b.x1) - avg(c.x2))/avg(b.x1)),0),<br />           0) as PERCENTCHANGE<br />from ACRES_640_PRODUCTION a,<br />    (select recnmbr, PRODUCTION x1<br />       from ACRES_640_PRODUCTION<br />      where year = 1990<br />        and product = 'G') b,<br />    (select recnmbr, PRODUCTION x2<br />       from ACRES_640_PRODUCTION<br />      where year = 2000<br />        and product = 'G') c<br />where a.recnmbr = b.recnmbr<br />and a.recnmbr = c.recnmbr<br />and a.year in (1990,2000)<br />and a.product = 'G'<br />group by a.recnmbr<br />union<br />select distinct b.recnmbr RECNMBR,<br />   19901 as PERCENTCHANGE<br />from (select recnmbr,<br />           PRODUCTION x1<br />      from ACRES_640_PRODUCTION<br />     where year = 1990<br />       and product = 'G') b<br />left outer join<br />   (select recnmbr, PRODUCTION x2<br />      from ACRES_640_PRODUCTION<br />     where year = 2000<br />       and product = 'G') c<br />on b.recnmbr = c.recnmbr<br />where b.x1 is not null<br />and c.x2 is null<br />union<br />select distinct c.recnmbr RECNMBR,<br />   20001 as PERCENTCHANGE<br />from (select recnmbr,<br />           PRODUCTION x1<br />      from ACRES_640_PRODUCTION<br />     where year = 1990<br />       and product = 'G') b<br />right outer join<br />   (select recnmbr,<br />           PRODUCTION x2<br />      from ACRES_640_PRODUCTION<br />     where year = 2000<br />       and product = 'G') c<br />on c.recnmbr = b.recnmbr<br />where c.x2 is not null<br />and b.x1 is null )</pre><br />Don't be frightened! The query should be broken up into three parts. The first part will compute the percent change between year 1990 and year 2000 for all the sections where we have gas production in 1990 and in 2000 (<b>and a.year in (1990,2000)</b>). Parts 2 and 3 of the union are specifically for sections that produce in one year, but not the other. The final map looks like...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/oil_gas_vc1990_2000_1.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/400/oil_gas_vc1990_2000_1.jpg" alt="" border="0"></a><br />Areas in red are places where gas production increased from 1990 to 2000. Areas in blue show a precent decreases. Areas in green did not produce in 1990. Areas in orange stopped producing by 2000. Email <a href="mailto:jbartley@kgs.ku.edu">me</a> if you have any questions.<br /><br />Next time we will look at sea-surface temeratures through time.   I know you can't wait!";}i:8;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-112483417733268508";s:7:"pubdate";s:31:"Tue, 23 Aug 2005 21:56:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2005-11-02T08:37:28.743-06:00";}s:5:"title";s:31:"Oracle Analytics to the rescue!";s:11:"description";s:12719:"Hi All-<br /><br />This is a great example of taking a traditional database setup that is not intimately integrated with GIS and "spatially enabling" it. I have been working on a web-based application that will map out areas in Kansas where (spatial) irrigators are authorized to irrigate. Here is a partial example of what I have from the database for Lane county, Kansas:<br /><span style=";font-family:Courier New;font-size:85%;"  ></span><br /><span style=";font-family:Courier New;font-size:85%;"  >location                 net_acres</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWSE            30</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWSW            40  </span><br /><br />The "location" is the legal description (<a href="http://www.kgs.ku.edu/Publications/pic20/pic20_1.html">PLSS</a>) of the area (down to 40 acre tracts; Township, Range, Section, Quarter, Quarter). The "net_acres" is the total amount that is authorized for that quarter-quarter section of land (up to 40 acres). The final map needs to display whether or not the quarter-quarter section is authorized for the full amount (40 acres) or whether it is only authorized for part of the quarter-quarter section (&lt; 40).<br /><br />To do this we need to join the legal description table with a spatial feature class (<a href="http://www.esri.com/software/arcgis/arcsde/index.html">SDE</a> layer) of the legal land parcels.  We can do a straight join to a spatial layer of 40 acres polygons (PLSS Q1, Q2) in ESRI´s <a href="http://www.esri.com/software/arcgis/arcims/index.html">ArcIMS</a> fairly easily.<br /><br /><br /><span style=";font-family:Courier New;font-size:85%;"  >&lt;LAYERDEF id="acres_640" visible="true" &gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;SPATIALQUERY searchorder="attributefirst"</span><br /><span style=";font-family:Courier New;font-size:85%;"  >           where="PLSS.ACRES_40.TRS = WIMAS.POU_LANE.LOCATION"</span><br /><span style=";font-family:Courier New;font-size:85%;"  >     jointables="WIMAS.POU_LANE"/&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;VALUEMAPRENDERER lookupfield="WIMAS.POU_LANE.TRACT" &gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;EXACT value="Whole Tract" label="Whole Tract"&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >    &lt;SIMPLEPOLYGONSYMBOL fillcolor="0,128,0" boundary="false" /&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/EXACT&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;EXACT value="Partial Tract" label="Partial Tract"&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >    &lt;SIMPLEPOLYGONSYMBOL fillcolor="0,255,0" boundary="false" /&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/EXACT&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/VALUEMAPRENDERER&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >&lt;/LAYERDEF&gt;</span><br /><br />This would be efficient if we did not have very large dataset, but some counties in Kansas can have more than 20,000 40-acre tracts! An attribute table join to a spatial table like this would not be efficient enough for the web.<br /><br />What can we do? Well if you look at table 1, you should see that there is a lot of repetition. If four quarter-quarter sections have the same value then why not join the attribute to the quarter section SDE layer (160 acres; four 40-acre tracts)? To do this we need use SQL to aggregate our results. This is where Oracle´s analytical functions come in very handy! Analytical functions are extremely powerful. I am not going to do them justice here, but if you want more information go to <a href="http://asktom.oracle.com/">AskTom</a> or to a great <a href="http://technology.amis.nl/blog/index.php?p=174">introduction to Analytical functions</a> by AMIS in the Netherlands.  A key thing to remember about analytical functions is that they are done <em>at the end of the sql statement, </em>just before the order by clause. So you are not limiting your results on the first pass with the use of analytical functions, but are doing inline analysis on the rows you have selected based on your criteria.<br /><br />Here is an example:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/image1.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/image1.jpg" alt="" border="0" /></a><span style=";font-family:Courier New;font-size:78%;"  ></span><br /><br />So the POU_LANE is a view that contains the data from the first table. What we want to do is use the "partition by" feature to aggreagte data within the current selection set.<br /><br /><blockquote  style="font-weight: bold;font-family:courier new;"><span style="font-size:85%;">first_value(substr(location, 1, 10))<br />over (partition by substr(location, 1, 10) ) a_160</span></blockquote><blockquote></blockquote>This part of the query groups (partition by) the first 10 characters of the location string (this would be the 160 acre polygons) and sets all rows of each group equal to the first value (first_value) that is recorded for each group. The difference between this and a traditional group by is that we can do this partition for each column in a recordset. This methodology can be very powerful if you think about.<br /><br /><span style="font-size:85%;"><span style="font-family:courier new;"></span><span style="font-weight: bold;font-family:courier new;" >       count(distinct sign(net_acres - 40))</span><br /><span style="font-weight: bold;font-family:courier new;" >         over (partition by substr(location, 1, 10)) dc_160,</span></span><br /><br />This part of the query does the same partition as above, except that it computes a count for the distinct irrigation tracts--whole tract (sign of 0) or partial tract (sign of -1).<br /><br /><blockquote  style="font-weight: bold;font-family:courier new;"><span style="font-size:85%;"> count(sign(net_acres - 40))<br />over (partition by substr(location, 1, 10)) tc_160,</span></blockquote>Here I am looking for a count of the number of 40 acre quarter-quarter sections in the 160 acre quarter sections. Again I am partitioning the records by the location (first 10 characters) within an individual column.<br /><br />Now we take the information from the analytical functions and perform our logic.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/finalquery.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/finalquery.jpg" alt="" border="0" /></a><span style="font-size:85%;"><span style="font-weight: bold;font-family:courier new;" ><br />select distinct</span><br /><span style="font-weight: bold;font-family:courier new;" >   case when dc_640 = 1 and tc_640 = 16 then a_640</span><br /><span style="font-weight: bold;font-family:courier new;" >        when dc_160 = 1 and tc_160 = 4 then a_160</span><br /><span style="font-weight: bold;font-family:courier new;" >        else location</span><br /><span style="font-weight: bold;font-family:courier new;" >    end location</span></span><br /><br />Here is the logic part of the query. I am using the case function in Oracle. Case allows you to perform if/then/else statements on a per row basis on your query results. So...<br /><ul>   <li>If there is only 1 distinct value (either whole tract or partial tract) in the dc_640 column and there are a total of 16 rows (16 rows that have the same a_640 value) in the tc_640 column then the row value is equal to the 8 character section identifier (a_640)</li>   <li>If there is only 1 distinct value (either whole tract or partial tract) in the dc_160 column and there are a total of 4 rows (4 rows that have the same a_160 value) in the tc_160 column then the row value is equal to the 10 character quarter-section identifier (a_160)<br /></li>   <li>If neither of the above are true then the location value is the full quarter-quarter-section.<br /></li> </ul> Slap a distinct on the row and we have reduced our mapping component from 32 40-acre polygons to 4 40-acre, 3 160-acre, and 1 640-acre polygon. This doesn't sound like much, but this example has only looked at 2 640-acre sections. For large irrigation counties in Kansas like Finney, I can reduce over 11,000 40-acre tracts to 3200 multi-sectional tracts.<br /><br />Finally we take the query above and put it into a view and, in ArcIMS, perform a join between the SDE spatial feature class layer and each legal grouping (640 acres, 160 acres, & 40 acres).<br /><br /><div style="text-align: center;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/arcrequest.jpg"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/arcrequest.jpg" alt="" border="0" /></a><br /></div><br /><br />Finally after all that we have a map....<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/map.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/map.jpg" alt="" border="0" /></a><br />I hope this was useful. If you have any questions, please feel free to post a comment. Oracle Analytical functions are a bit complicated at first, but once you understand them they can be extremely powerful and useful.<br /><br />Cheers,<br /><br />Jeremy";s:4:"link";s:66:"http://geosql.blogspot.com/2005/08/oracle-analytics-to-rescue.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"0";}s:7:"summary";s:12719:"Hi All-<br /><br />This is a great example of taking a traditional database setup that is not intimately integrated with GIS and "spatially enabling" it. I have been working on a web-based application that will map out areas in Kansas where (spatial) irrigators are authorized to irrigate. Here is a partial example of what I have from the database for Lane county, Kansas:<br /><span style=";font-family:Courier New;font-size:85%;"  ></span><br /><span style=";font-family:Courier New;font-size:85%;"  >location                 net_acres</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22NWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWSE            30</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W22SWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23NWSW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SENE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SENW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SESE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SESW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWNE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWNW            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWSE            40</span><br /><span style=";font-family:Courier New;font-size:85%;"  >17S28W23SWSW            40  </span><br /><br />The "location" is the legal description (<a href="http://www.kgs.ku.edu/Publications/pic20/pic20_1.html">PLSS</a>) of the area (down to 40 acre tracts; Township, Range, Section, Quarter, Quarter). The "net_acres" is the total amount that is authorized for that quarter-quarter section of land (up to 40 acres). The final map needs to display whether or not the quarter-quarter section is authorized for the full amount (40 acres) or whether it is only authorized for part of the quarter-quarter section (&lt; 40).<br /><br />To do this we need to join the legal description table with a spatial feature class (<a href="http://www.esri.com/software/arcgis/arcsde/index.html">SDE</a> layer) of the legal land parcels.  We can do a straight join to a spatial layer of 40 acres polygons (PLSS Q1, Q2) in ESRI´s <a href="http://www.esri.com/software/arcgis/arcims/index.html">ArcIMS</a> fairly easily.<br /><br /><br /><span style=";font-family:Courier New;font-size:85%;"  >&lt;LAYERDEF id="acres_640" visible="true" &gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;SPATIALQUERY searchorder="attributefirst"</span><br /><span style=";font-family:Courier New;font-size:85%;"  >           where="PLSS.ACRES_40.TRS = WIMAS.POU_LANE.LOCATION"</span><br /><span style=";font-family:Courier New;font-size:85%;"  >     jointables="WIMAS.POU_LANE"/&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;VALUEMAPRENDERER lookupfield="WIMAS.POU_LANE.TRACT" &gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;EXACT value="Whole Tract" label="Whole Tract"&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >    &lt;SIMPLEPOLYGONSYMBOL fillcolor="0,128,0" boundary="false" /&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/EXACT&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;EXACT value="Partial Tract" label="Partial Tract"&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >    &lt;SIMPLEPOLYGONSYMBOL fillcolor="0,255,0" boundary="false" /&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/EXACT&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >  &lt;/VALUEMAPRENDERER&gt;</span><br /><span style=";font-family:Courier New;font-size:85%;"  >&lt;/LAYERDEF&gt;</span><br /><br />This would be efficient if we did not have very large dataset, but some counties in Kansas can have more than 20,000 40-acre tracts! An attribute table join to a spatial table like this would not be efficient enough for the web.<br /><br />What can we do? Well if you look at table 1, you should see that there is a lot of repetition. If four quarter-quarter sections have the same value then why not join the attribute to the quarter section SDE layer (160 acres; four 40-acre tracts)? To do this we need use SQL to aggregate our results. This is where Oracle´s analytical functions come in very handy! Analytical functions are extremely powerful. I am not going to do them justice here, but if you want more information go to <a href="http://asktom.oracle.com/">AskTom</a> or to a great <a href="http://technology.amis.nl/blog/index.php?p=174">introduction to Analytical functions</a> by AMIS in the Netherlands.  A key thing to remember about analytical functions is that they are done <em>at the end of the sql statement, </em>just before the order by clause. So you are not limiting your results on the first pass with the use of analytical functions, but are doing inline analysis on the rows you have selected based on your criteria.<br /><br />Here is an example:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/image1.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/image1.jpg" alt="" border="0" /></a><span style=";font-family:Courier New;font-size:78%;"  ></span><br /><br />So the POU_LANE is a view that contains the data from the first table. What we want to do is use the "partition by" feature to aggreagte data within the current selection set.<br /><br /><blockquote  style="font-weight: bold;font-family:courier new;"><span style="font-size:85%;">first_value(substr(location, 1, 10))<br />over (partition by substr(location, 1, 10) ) a_160</span></blockquote><blockquote></blockquote>This part of the query groups (partition by) the first 10 characters of the location string (this would be the 160 acre polygons) and sets all rows of each group equal to the first value (first_value) that is recorded for each group. The difference between this and a traditional group by is that we can do this partition for each column in a recordset. This methodology can be very powerful if you think about.<br /><br /><span style="font-size:85%;"><span style="font-family:courier new;"></span><span style="font-weight: bold;font-family:courier new;" >       count(distinct sign(net_acres - 40))</span><br /><span style="font-weight: bold;font-family:courier new;" >         over (partition by substr(location, 1, 10)) dc_160,</span></span><br /><br />This part of the query does the same partition as above, except that it computes a count for the distinct irrigation tracts--whole tract (sign of 0) or partial tract (sign of -1).<br /><br /><blockquote  style="font-weight: bold;font-family:courier new;"><span style="font-size:85%;"> count(sign(net_acres - 40))<br />over (partition by substr(location, 1, 10)) tc_160,</span></blockquote>Here I am looking for a count of the number of 40 acre quarter-quarter sections in the 160 acre quarter sections. Again I am partitioning the records by the location (first 10 characters) within an individual column.<br /><br />Now we take the information from the analytical functions and perform our logic.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/finalquery.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/finalquery.jpg" alt="" border="0" /></a><span style="font-size:85%;"><span style="font-weight: bold;font-family:courier new;" ><br />select distinct</span><br /><span style="font-weight: bold;font-family:courier new;" >   case when dc_640 = 1 and tc_640 = 16 then a_640</span><br /><span style="font-weight: bold;font-family:courier new;" >        when dc_160 = 1 and tc_160 = 4 then a_160</span><br /><span style="font-weight: bold;font-family:courier new;" >        else location</span><br /><span style="font-weight: bold;font-family:courier new;" >    end location</span></span><br /><br />Here is the logic part of the query. I am using the case function in Oracle. Case allows you to perform if/then/else statements on a per row basis on your query results. So...<br /><ul>   <li>If there is only 1 distinct value (either whole tract or partial tract) in the dc_640 column and there are a total of 16 rows (16 rows that have the same a_640 value) in the tc_640 column then the row value is equal to the 8 character section identifier (a_640)</li>   <li>If there is only 1 distinct value (either whole tract or partial tract) in the dc_160 column and there are a total of 4 rows (4 rows that have the same a_160 value) in the tc_160 column then the row value is equal to the 10 character quarter-section identifier (a_160)<br /></li>   <li>If neither of the above are true then the location value is the full quarter-quarter-section.<br /></li> </ul> Slap a distinct on the row and we have reduced our mapping component from 32 40-acre polygons to 4 40-acre, 3 160-acre, and 1 640-acre polygon. This doesn't sound like much, but this example has only looked at 2 640-acre sections. For large irrigation counties in Kansas like Finney, I can reduce over 11,000 40-acre tracts to 3200 multi-sectional tracts.<br /><br />Finally we take the query above and put it into a view and, in ArcIMS, perform a join between the SDE spatial feature class layer and each legal grouping (640 acres, 160 acres, & 40 acres).<br /><br /><div style="text-align: center;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/arcrequest.jpg"><img style="cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/arcrequest.jpg" alt="" border="0" /></a><br /></div><br /><br />Finally after all that we have a map....<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/blogger/7515/1455/1600/map.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://photos1.blogger.com/blogger/7515/1455/320/map.jpg" alt="" border="0" /></a><br />I hope this was useful. If you have any questions, please feel free to post a comment. Oracle Analytical functions are a bit complicated at first, but once you understand them they can be extremely powerful and useful.<br /><br />Cheers,<br /><br />Jeremy";}i:9;a:9:{s:4:"guid";s:58:"tag:blogger.com,1999:blog-15655029.post-112467806637157826";s:7:"pubdate";s:31:"Mon, 22 Aug 2005 02:22:00 +0000";s:4:"atom";a:1:{s:7:"updated";s:29:"2005-08-21T21:34:26.376-05:00";}s:5:"title";s:19:"SQL for Geographers";s:11:"description";s:696:"Hi All-<br /><p class="Achievement" style="margin-left: 0in; text-indent: 0in;">This blog is dedicated to the integration between GIS and enterprise level relational databases. I am a Geographer by trade with a strong interest in relational databases. I have been in the GIS field for 10+ years and the database field for 7. The amount of data waiting to be spatially enabled within enterprise databases is extraordinary. I hope to show in this blog working examples of database-GIS interaction. Many examples that I will show are implemented within Oracle 9.2 and ESRI's SDE 8.3. Hopefully most of the SQL algorithms will transfer to your implementation. Stay tuned for more...<br /></p>  Jeremy";s:4:"link";s:59:"http://geosql.blogspot.com/2005/08/sql-for-geographers.html";s:6:"author";s:28:"noreply@blogger.com (Jeremy)";s:3:"thr";a:1:{s:5:"total";s:1:"1";}s:7:"summary";s:696:"Hi All-<br /><p class="Achievement" style="margin-left: 0in; text-indent: 0in;">This blog is dedicated to the integration between GIS and enterprise level relational databases. I am a Geographer by trade with a strong interest in relational databases. I have been in the GIS field for 10+ years and the database field for 7. The amount of data waiting to be spatially enabled within enterprise databases is extraordinary. I hope to show in this blog working examples of database-GIS interaction. Many examples that I will show are implemented within Oracle 9.2 and ESRI's SDE 8.3. Hopefully most of the SQL algorithms will transfer to your implementation. Stay tuned for more...<br /></p>  Jeremy";}}s:7:"channel";a:9:{s:4:"atom";a:1:{s:2:"id";s:34:"tag:blogger.com,1999:blog-15655029";}s:13:"lastbuilddate";s:31:"Fri, 03 Oct 2014 07:44:37 +0000";s:5:"title";s:19:"SQL for Geographers";s:11:"description";s:268:"This blog is dedicated to the integration between GIS and enterprise level relational databases.  The amount of data waiting to be spatially enabled within enterprise databases is extraordinary. I hope to show in this blog working examples of database-GIS interaction.";s:4:"link";s:27:"http://geosql.blogspot.com/";s:14:"managingeditor";s:28:"noreply@blogger.com (Jeremy)";s:9:"generator";s:7:"Blogger";s:10:"opensearch";a:3:{s:12:"totalresults";s:2:"10";s:10:"startindex";s:1:"1";s:12:"itemsperpage";s:2:"25";}s:7:"tagline";s:268:"This blog is dedicated to the integration between GIS and enterprise level relational databases.  The amount of data waiting to be spatially enabled within enterprise databases is extraordinary. I hope to show in this blog working examples of database-GIS interaction.";}s:9:"textinput";a:0:{}s:5:"image";a:0:{}s:9:"feed_type";s:3:"RSS";s:12:"feed_version";s:3:"2.0";s:5:"stack";a:0:{}s:9:"inchannel";b:0;s:6:"initem";b:0;s:9:"incontent";b:0;s:11:"intextinput";b:0;s:7:"inimage";b:0;s:13:"current_field";s:0:"";s:17:"current_namespace";b:0;s:5:"ERROR";s:0:"";s:19:"_CONTENT_CONSTRUCTS";a:6:{i:0;s:7:"content";i:1;s:7:"summary";i:2;s:4:"info";i:3;s:5:"title";i:4;s:7:"tagline";i:5;s:9:"copyright";}s:4:"etag";s:42:"W/"a4ec3a83-8d66-4a50-bd43-03a36d627ccc"
";s:13:"last_modified";s:31:"Fri, 03 Oct 2014 07:44:37 GMT
";}